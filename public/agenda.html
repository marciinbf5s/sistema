<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agenda - Sistema de Agendamento</title>
    
    <!-- CSS Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    
    <!-- Custom CSS -->
    <link href="css/sidebar.css" rel="stylesheet">
    <link href="css/theme.css" rel="stylesheet">
    
    <style>
        :root {
            --primary: #f0b354;    /* Dourado */
            --primary-hover: #d9a24a;   /* Dourado mais escuro */
            --secondary: #041a31; /* Azul Royal */
            --secondary-hover: #031425; /* Azul Royal mais escuro */
            --light: #f8f9fa;
            --dark: #212529;
            --background-light: #f6f8f8;
            --border-color: rgba(4, 26, 49, 0.1);
        }
        
        body {
            background-color: var(--background-light);
            font-family: 'Inter', sans-serif;
            color: var(--dark);
            overflow-x: hidden;
        }
        
        /* Estilos do Calendário */
        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            text-align: center;
            font-weight: 500;
            color: #6c757d;
            margin-bottom: 0.5rem;
        }
        
        .calendar-days {
            display: grid;
            grid-template-columns: repeat(7, minmax(0, 1fr));
            gap: 0.25rem;
            width: 100%;
            margin: 0 auto;
        }
        
        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            width: 100%;
            max-width: 2.5rem;
            height: auto;
            margin: 0 auto;
            font-size: 0.9rem;
        }
        
        .calendar-day:hover {
            background-color: rgba(240, 179, 84, 0.1);
        }
        
        .calendar-day.active {
            background-color: var(--primary);
            color: white;
            font-weight: 600;
        }
        
        .calendar-day.today {
            background-color: rgba(240, 179, 84, 0.4);
            font-weight: 600;
            color: #212529;
        }
        
        .calendar-day.text-muted {
            color: #adb5bd !important;
        }
        
        .status-badge {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Cores e estilos para cada status */
        .status-agendado, .status-AGENDADO {
            background-color: #e3f2fd;
            color: #0d6efd;
            border: 1px solid rgba(13, 110, 253, 0.2);
        }
        
        .status-confirmado, .status-CONFIRMADO {
            background-color: #e8f5e9;
            color: #2e7d32;
            border: 1px solid rgba(46, 125, 50, 0.2);
        }
        
        .status-cancelado, .status-CANCELADO {
            background-color: #f8d7da;
            color: #b02a37;
            border: 1px solid rgba(211, 47, 47, 0.2);
            text-decoration: line-through;
            opacity: 0.8;
        }
        
        .status-finalizado, .status-FINALIZADO {
            background-color: #e8f5e9;
            color: #0f5132;
            border: 1px solid rgba(46, 125, 50, 0.2);
        }
        
        .status-em_andamento, .status-EM_ANDAMENTO {
            background-color: #fff3e0;
            color: #d46a08;
            border: 1px solid rgba(237, 108, 2, 0.2);
            font-weight: 600;
        }
        
        .status-faltou, .status-FALTOU {
            background-color: #f3e5f5;
            color: #7b1fa2;
            border: 1px solid rgba(123, 31, 162, 0.2);
        }
        
        /* Estilo para os itens da lista com status de cancelado */
        .list-group-item.status-cancelado,
        .list-group-item.status-CANCELADO {
            background-color: #fff9f9;
            opacity: 0.8;
        }
        
        .list-group-item.status-cancelado .text-muted,
        .list-group-item.status-CANCELADO .text-muted {
            opacity: 0.7;
        }
        
        .list-group-item.status-cancelado h6,
        .list-group-item.status-CANCELADO h6,
        .list-group-item.status-cancelado .mb-1,
        .list-group-item.status-CANCELADO .mb-1 {
            text-decoration: line-through;
            opacity: 0.7;
        }
        
        @media (max-width: 576px) {
            .calendar-day {
                max-width: 1.8rem;
                font-size: 0.75rem;
            }
            .calendar-day {
                max-width: 1.8rem;
                font-size: 0.75rem;
            }
        }

        /* Legenda de status abaixo do calendário */
        .legend-status {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
            align-items: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--dark);
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.06);
            box-shadow: 0 0 0 2px rgba(255,255,255,0.6) inset;
        }

        /* Cores mais fortes para a legenda */
        .legend-agendado { background: #3d8bfd; }      /* azul mais forte */
        .legend-andamento { background: #ffc107; }     /* amarelo mais forte */
        .legend-finalizado { background: #198754; }    /* verde mais forte */
        .legend-cancelado { background: #dc3545; }     /* vermelho mais forte */

        /* Backgrounds para itens de agendamento por status */
        .list-group-item.status-AGENDADO { background-color: #cfe8ff; }
        .list-group-item.status-EM_ANDAMENTO { background-color: #fff6d6; }
        .list-group-item.status-FINALIZADO { background-color: #d8f6dc; }
        .list-group-item.status-CANCELADO { background-color: #f8d7da; }

        /* Pequena borda e contraste para melhor leitura */
        .list-group-item.status-AGENDADO,
        .list-group-item.status-EM_ANDAMENTO,
        .list-group-item.status-FINALIZADO,
        .list-group-item.status-CANCELADO {
            border: 1px solid rgba(0,0,0,0.04);
        }

        /* Aumentar separação entre itens e adicionar traço mais escuro */
        .list-group-item.status-AGENDADO,
        .list-group-item.status-EM_ANDAMENTO,
        .list-group-item.status-FINALIZADO,
        .list-group-item.status-CANCELADO {
            padding: 0.75rem 1rem;
            margin-bottom: 0.45rem;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(16,24,40,0.03);
            position: relative;
            overflow: visible;
            border: 1px solid rgba(0,0,0,0.12); /* borda geral mais forte */
            transition: transform 0.12s ease, box-shadow 0.12s ease, border-left-color 0.12s ease;
        }

        /* borda esquerda colorida por status para destacar */
        .list-group-item.status-AGENDADO { border-left: 4px solid rgba(67,97,238,0.95); }
        .list-group-item.status-EM_ANDAMENTO { border-left: 4px solid rgba(255,193,7,0.95); }
        .list-group-item.status-FINALIZADO { border-left: 4px solid rgba(75,181,67,0.95); }
        .list-group-item.status-CANCELADO { border-left: 4px solid rgba(220,53,69,0.95); }

        /* separador consistente: borda-top para itens seguintes (evita traço 'solto') */
        .list-group-item.status-AGENDADO + .list-group-item.status-AGENDADO,
        .list-group-item.status-EM_ANDAMENTO + .list-group-item.status-EM_ANDAMENTO,
        .list-group-item.status-FINALIZADO + .list-group-item.status-FINALIZADO,
        .list-group-item.status-CANCELADO + .list-group-item.status-CANCELADO,
        /* também aplicar quando status diferentes entre itens */
        .list-group-item.status-CANCELADO + .list-group-item {
            border-top: 1px solid rgba(0,0,0,0.10);
            margin-top: 0.4rem; /* espaço antes do traço */
            padding-top: 0.4rem; /* espaço interno após o traço */
        }

        /* Ajuste de alinhamento dos ícones dos botões */
        .btn-group-sm > .btn i {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1em;
            height: 1em;
            line-height: 1;
        }
        
        /* Ajuste específico para o ícone de check no botão de finalizar */
        /* Estilos para os botões de ação */
        .action-buttons {
            display: flex;
            gap: 5px;
            justify-content: center;
        }
        
        .action-buttons .btn {
            width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            border-radius: 4px;
        }
        
        /* Botão Finalizar - Verde suave */
        .action-buttons .btn-outline-success {
            color: #2e7d32;
            border-color: #a5d6a7;
            background-color: #e8f5e9;
        }
        
        .action-buttons .btn-outline-success:hover {
            background-color: #2e7d32;
            color: white;
            border-color: #2e7d32;
        }
        
        /* Botão Editar - Amarelo suave */
        .action-buttons .btn-outline-primary {
            color: #ed6c02;
            border-color: #ffe082;
            background-color: #fff8e1;
        }
        
        .action-buttons .btn-outline-primary:hover {
            background-color: #ed6c02;
            color: white;
            border-color: #ed6c02;
        }
        
        /* Botão Cancelar - Vermelho suave */
        .action-buttons .btn-outline-danger {
            color: #d32f2f;
            border-color: #ffcdd2;
            background-color: #ffebee;
        }
        
        .action-buttons .btn-outline-danger:hover {
            background-color: #d32f2f;
            color: white;
            border-color: #d32f2f;
        }

        /* Estilo escuro para tooltips */
        .tooltip {
            --bs-tooltip-bg: #212529;
            --bs-tooltip-color: #fff;
        }
        
        .tooltip-inner {
            background-color: var(--bs-tooltip-bg);
            color: var(--bs-tooltip-color);
            font-size: 0.8rem;
            padding: 0.35rem 0.75rem;
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.2);
        }
        
        .bs-tooltip-auto[data-popper-placement^=top] .tooltip-arrow::before,
        .bs-tooltip-top .tooltip-arrow::before {
            border-top-color: var(--bs-tooltip-bg);
        }
        
        .bs-tooltip-auto[data-popper-placement^=right] .tooltip-arrow::before,
        .bs-tooltip-end .tooltip-arrow::before {
            border-right-color: var(--bs-tooltip-bg);
        }
        
        .bs-tooltip-auto[data-popper-placement^=bottom] .tooltip-arrow::before,
        .bs-tooltip-bottom .tooltip-arrow::before {
            border-bottom-color: var(--bs-tooltip-bg);
        }
        
        .bs-tooltip-auto[data-popper-placement^=left] .tooltip-arrow::before,
        .bs-tooltip-start .tooltip-arrow::before {
            border-left-color: var(--bs-tooltip-bg);
        }

        .list-group-item.status-AGENDADO:last-child,
        .list-group-item.status-EM_ANDAMENTO:last-child,
        .list-group-item.status-FINALIZADO:last-child,
        .list-group-item.status-CANCELADO:last-child {
            margin-bottom: 0;
        }

        /* Aplicar o mesmo tom de cinza e estilo de texto da tabela de clientes na aba 'Lista' */
        /* Usamos selectors com escopo para evitar interferir em outras tabelas */
        #list-tab-pane .table {
            --bs-table-striped-bg: #f8f9fa; /* tom de cinza usado na tabela de clientes */
            --bs-table-hover-bg: #f1f3f5;
            background-color: transparent;
        }

        /* Aplicar background aos rows e hover similar à tabela clientes */
        #list-tab-pane .table tbody tr {
            background-color: var(--bs-table-striped-bg);
        }

        #list-tab-pane .table tbody tr:hover {
            background-color: var(--bs-table-hover-bg);
        }

        /* Texto preto e negrito nas células */
        #list-tab-pane .table tbody tr td {
            color: #000 !important;
            font-weight: 600 !important;
        }

        /* Cabeçalho da tabela (linha de títulos) com fundo claro que combina com o tema */
        #list-tab-pane .table thead th {
            background-color: #fff4de !important; /* dourado bem claro */
            color: #212529 !important; /* texto escuro */
            font-weight: 700 !important;
            border-bottom: 1px solid rgba(240, 179, 84, 0.35) !important;
        }

        /* Estilo da lista de agendamentos com barra de rolagem personalizada */
        #appointmentsList {
            max-height: 65vh;
            overflow-y: auto;
            padding-right: 8px;
            scrollbar-width: thin;
            scrollbar-color: #f0b354 #f8f9fa;
        }

        /* Estilo da barra de rolagem para WebKit (Chrome, Safari, Edge) */
        #appointmentsList::-webkit-scrollbar {
            width: 8px;
        }
        
        #appointmentsList::-webkit-scrollbar-track {
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        #appointmentsList::-webkit-scrollbar-thumb {
            background-color: #f0b354;
            border-radius: 4px;
        }
        
        #appointmentsList::-webkit-scrollbar-thumb:hover {
            background-color: #d9a24a;
        }
        
        /* Estilo da barra de rolagem para Firefox */
        #appointmentsList {
            scrollbar-width: thin;
            scrollbar-color: #f0b354 #f8f9fa;
        }

        /* Espaçamento entre os itens da lista */
        .appointment-item {
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="d-flex">
        <!-- Menu lateral -->
        <div id="sidebar"></div>
        
        <!-- Conteúdo principal -->
        <div class="main-content flex-grow-1">
            <div class="container-fluid p-0">
                <!-- Botão para mobile -->
                <button class="btn btn-primary d-lg-none mb-3" id="sidebarToggle">
                    <i class="bi bi-list"></i> Menu
                </button>
                
                <!-- Cabeçalho (estilo igual à página Clientes) -->
                <div class="page-header mb-4">
                    <div class="row align-items-center mb-3">
                        <div class="col-12 col-md-6 mb-3 mb-md-0">
                            <div>
                                <h1 class="page-title fw-bolder" style="font-weight: 800 !important; margin-bottom: 10px;">
                                    <i class="bi bi-calendar-event-fill me-2" style="color: #f0b354;"></i>Agenda
                                </h1>
                                <p class="text-muted mb-0 mt-2">Gerencie os agendamentos do seu negócio</p>
                            </div>
                        </div>
                        <div class="col-12 col-md-6">
                            <div class="d-flex flex-wrap justify-content-md-end" style="gap: 10px;">
                                <button class="btn btn-primary d-flex align-items-center" id="newAgendamentoBtn" style="height: 38px;">
                                    <i class="bi bi-plus-lg me-1"></i>
                                    <span class="d-none d-sm-inline">Novo Agendamento</span>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="border-bottom mt-3"></div>
                </div>
                
                <!-- Abas de Navegação -->
                <ul class="nav nav-tabs mb-4" id="mainTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="calendar-tab" data-bs-toggle="tab" 
                                data-bs-target="#calendar-tab-pane" type="button" role="tab" 
                                aria-controls="calendar-tab-pane" aria-selected="true">
                            <i class="bi bi-calendar3 me-2"></i>Calendário
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="list-tab" data-bs-toggle="tab" 
                                data-bs-target="#list-tab-pane" type="button" role="tab" 
                                aria-controls="list-tab-pane" aria-selected="false">
                            <i class="bi bi-list-ul me-2"></i>Lista
                        </button>
                    </li>
                </ul>
                
                <!-- Conteúdo das Abas -->
                <div class="tab-content" id="mainTabsContent">
                    <!-- Aba do Calendário -->
                    <div class="tab-pane fade show active" id="calendar-tab-pane" role="tabpanel" aria-labelledby="calendar-tab" tabindex="0">
                        <div class="row g-4">
                            <!-- Calendário -->
                            <div class="col-lg-4">
                                <div class="card">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center mb-3">
                                            <h5 class="card-title mb-0">Calendário</h5>
                                            <div class="btn-group">
                                                <button class="btn btn-sm btn-outline-secondary" id="prevMonth">
                                                    <i class="bi bi-chevron-left"></i>
                                                </button>
                                                <button class="btn btn-sm btn-outline-secondary position-relative" id="currentMonth">
                                                    <span id="currentMonthText">Outubro 2023</span>
                                                </button>
                                                <!-- Seletor de mês/ano (inicialmente escondido) -->
                                                <div id="monthPicker" class="card p-2 position-absolute d-none" style="z-index:1050; min-width:200px; top:40px; left:0">
                                                    <div class="d-flex gap-2 align-items-center mb-2">
                                                        <select id="monthSelect" class="form-select form-select-sm">
                                                            <option value="0">Janeiro</option>
                                                            <option value="1">Fevereiro</option>
                                                            <option value="2">Março</option>
                                                            <option value="3">Abril</option>
                                                            <option value="4">Maio</option>
                                                            <option value="5">Junho</option>
                                                            <option value="6">Julho</option>
                                                            <option value="7">Agosto</option>
                                                            <option value="8">Setembro</option>
                                                            <option value="9">Outubro</option>
                                                            <option value="10">Novembro</option>
                                                            <option value="11">Dezembro</option>
                                                        </select>
                                                        <input id="yearInput" class="form-control form-control-sm" type="number" style="width:90px" />
                                                    </div>
                                                    <div class="d-flex justify-content-end gap-2">
                                                        <button id="monthPickerCancel" class="btn btn-sm btn-secondary">Cancelar</button>
                                                        <button id="monthPickerGo" class="btn btn-sm btn-primary">Ir</button>
                                                    </div>
                                                </div>
                                                <button class="btn btn-sm btn-outline-secondary" id="nextMonth">
                                                    <i class="bi bi-chevron-right"></i>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="calendar-container">
                                            <div class="calendar-weekdays">
                                                <div>Dom</div>
                                                <div>Seg</div>
                                                <div>Ter</div>
                                                <div>Qua</div>
                                                <div>Qui</div>
                                                <div>Sex</div>
                                                <div>Sáb</div>
                                            </div>
                                            <div class="calendar-days" id="calendarDays">
                                                <!-- Dias serão preenchidos via JavaScript -->
                                            </div>
                                            <!-- Legenda de status -->
                                            <div class="legend-status" aria-hidden="false">
                                                <div class="legend-item"><span class="legend-color legend-agendado" aria-hidden="true"></span> Agendado</div>
                                                <div class="legend-item"><span class="legend-color legend-andamento" aria-hidden="true"></span> Em andamento</div>
                                                <div class="legend-item"><span class="legend-color legend-finalizado" aria-hidden="true"></span> Finalizado</div>
                                                <div class="legend-item"><span class="legend-color legend-cancelado" aria-hidden="true"></span> Cancelado</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Lista de Agendamentos -->
                            <div class="col-lg-8">
                                <div class="card">
                                    <div class="card-body">
                                        <h5 class="card-title mb-2">Agendamentos para <span id="selectedDate">hoje</span></h5>
                                        <!-- Separador visual destacado -->
                                        <div class="appointments-separator-wrapper mb-3">
                                            <hr class="appointments-separator" />
                                        </div>
                                        
                                        <div id="appointmentsList">
                                            <!-- Controles de estado: spinner, mensagem vazia e lista -->
                                            <div id="appointmentsLoading" class="text-center py-5 d-none" aria-live="polite">
                                                <div class="spinner-border text-primary" role="status" aria-hidden="true"></div>
                                                <div class="mt-2 text-muted">Carregando agendamentos...</div>
                                            </div>

                                            <div id="appointmentsEmpty" class="text-center text-muted py-5 d-none" aria-live="polite">
                                                <i class="bi bi-calendar-x fs-1 mb-3 d-block" aria-hidden="true"></i>
                                                <p>Nenhum agendamento encontrado para esta data.</p>
                                            </div>

                                            <div id="appointmentsContainer" class="list-group d-none">
                                                <!-- Lista de agendamentos será preenchida via JavaScript -->
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Aba de Lista -->
                    <div class="tab-pane fade" id="list-tab-pane" role="tabpanel" aria-labelledby="list-tab" tabindex="0">
                        <div class="card border-0 shadow-sm">
                            <div class="card-header py-3 px-4" style="background-color: #dee2e6; border-bottom: 1px solid rgba(0,0,0,0.05);">
                                <div class="d-flex flex-column flex-md-row justify-content-between align-items-center gap-3">
                                    <h1 class="h5 mb-0 fw-normal text-dark">Agenda de Atendimentos</h1>
                                    <div class="d-flex gap-2">
                                        <button class="btn btn-sm btn-outline-secondary" id="prevDay" title="Dia anterior">
                                            <i class="bi bi-chevron-left"></i>
                                        </button>
                                        <div id="dateDisplayContainer" class="d-flex align-items-center px-3 border rounded bg-white">
                                            <span id="currentDateDisplay" class="fw-medium">Hoje</span>
                                        </div>
                                        <button class="btn btn-sm btn-outline-secondary border" id="nextDay" title="Próximo dia">
                                            <i class="bi bi-chevron-right"></i>
                                        </button>
                                        <button class="btn btn-sm btn-outline-primary border" id="todayBtn" title="Ir para hoje">
                                            <i class="bi bi-calendar-check"></i>
                                        </button>
                                        <style>
                                            #dateDisplayContainer {
                                                min-width: 100px;
                                                height: 31.6px;
                                                display: flex;
                                                align-items: center;
                                                justify-content: center;
                                                background-color: #f8f9fa;
                                                border: 1px solid #dee2e6 !important;
                                            }
                                            .btn-outline-secondary {
                                                border-color: #dee2e6;
                                            }
                                            .btn-outline-secondary:hover {
                                                background-color: #f8f9fa;
                                            }
                                        </style>
                                    </div>
                                </div>
                            </div>
                            <div class="card-body p-0">
                                <div class="table-responsive">
                                    <table class="table table-hover align-middle">
                                        <thead>
                                            <tr>
                                                <th>Data/Hora</th>
                                                <th>Cliente</th>
                                                <th>Profissional</th>
                                                <th>Procedimento</th>
                                                <th>Status</th>
                                                <th class="text-end">Ações</th>
                                            </tr>
                                        </thead>
                                        <tbody id="appointmentsTableBody">
                                            <tr id="loadingRow">
                                                <td colspan="6" class="text-center py-5 d-none">
                                                    <div class="d-flex justify-content-center">
                                                        <div class="spinner-border text-primary" role="status">
                                                            <span class="visually-hidden">Carregando...</span>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                            <tr id="emptyAppointmentsRow" class="d-none">
                                                <td colspan="6" class="text-center py-5">
                                                    <div class="d-flex flex-column align-items-center">
                                                        <i class="bi bi-calendar-x text-muted mb-2" style="font-size: 2rem;"></i>
                                                        <p class="text-muted mb-0">Nenhum agendamento encontrado para esta data.</p>
                                                    </div>
                                                </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                
                                <div id="paginationContainer" class="mt-4" style="display: none;">
                                    <nav aria-label="Navegação de páginas">
                                        <ul class="pagination justify-content-center" id="paginationList">
                                            <!-- Pagination will be inserted here by JavaScript -->
                                        </ul>
                                    </nav>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Novo Agendamento -->
    <div class="modal fade" id="agendamentoModal" tabindex="-1" aria-hidden="true" data-bs-backdrop="static">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Novo Agendamento</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
                </div>
                <form id="agendamentoForm">
                    <input type="hidden" id="agendamentoId" name="agendamentoId">
                    <div class="modal-body">
                        <div class="row g-3">
                            <div class="col-md-6">
                                <label for="clienteId" class="form-label">Cliente <span class="text-danger">*</span></label>
                                <select class="form-select" id="clienteId" name="clienteId" required>
                                    <option value="">Selecione um cliente</option>
                                    <!-- Opções serão preenchidas via JavaScript -->
                                </select>
                            </div>
                            <div class="col-md-6">
                                <label for="procedimentoId" class="form-label">Procedimento <span class="text-danger">*</span></label>
                                <select class="form-select" id="procedimentoId" name="procedimentoId" required>
                                    <option value="">Selecione um procedimento</option>
                                    <!-- Opções serão preenchidas via JavaScript -->
                                </select>
                            </div>
                            <div class="col-md-12">
                                <label for="profissionalId" class="form-label">Profissional</label>
                                <select class="form-select" id="profissionalId" name="profissionalId">
                                    <option value="">Selecione um profissional</option>
                                    <!-- Opções serão preenchidas via JavaScript -->
                                </select>
                            </div>
                            <div class="col-md-4">
                                <label for="data" class="form-label">Data <span class="text-danger">*</span></label>
                                <input type="date" class="form-control" id="data" name="data" required>
                            </div>
                            <div class="col-md-4">
                                <label for="horaInicio" class="form-label">Hora Início <span class="text-danger">*</span></label>
                                <input type="time" class="form-control" id="horaInicio" name="horaInicio" required>
                            </div>
                            <div class="col-md-4">
                                <label for="duracao" class="form-label">Duração (min) <span class="text-danger">*</span></label>
                                <input type="number" class="form-control" id="duracao" name="duracao" min="15" step="15" value="60" required>
                            </div>
                            <div class="col-md-6">
                                <label for="valorCobrado" class="form-label">Valor Cobrado (R$) <span class="text-danger">*</span></label>
                                <div class="input-group">
                                    <span class="input-group-text">R$</span>
                                    <input type="number" class="form-control" id="valorCobrado" name="valorCobrado" min="0" step="0.01" required>
                                </div>
                            </div>
                            <div class="col-12">
                                <label for="observacoes" class="form-label">Observações</label>
                                <textarea class="form-control" id="observacoes" name="observacoes" rows="3"></textarea>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                        <button type="submit" class="btn btn-primary" id="btnSalvar">
                            <span class="spinner-border spinner-border-sm d-none" id="loadingSpinner" role="status" aria-hidden="true"></span>
                            <span id="btnText">Salvar</span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Modal de Confirmação de Cancelamento -->
    <div class="modal fade" id="confirmarCancelamentoModal" tabindex="-1" aria-labelledby="confirmarCancelamentoLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="confirmarCancelamentoLabel">Confirmar Cancelamento</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
                </div>
                <div class="modal-body">
                    Tem certeza que deseja cancelar este agendamento?
                    <input type="hidden" id="confirmarCancelamentoId">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Não</button>
                    <button type="button" class="btn btn-danger" onclick="confirmarCancelamento()">Sim, Cancelar</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Erro de Validação -->
    <div class="modal fade" id="erroValidacaoModal" data-bs-backdrop="static" tabindex="-1" aria-labelledby="erroValidacaoLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-warning text-dark">
                    <h5 class="modal-title" id="erroValidacaoLabel">Atenção</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
                </div>
                <div class="modal-body">
                    <div class="text-center mb-3">
                        <i class="bi bi-exclamation-triangle-fill text-warning" style="font-size: 3rem;"></i>
                    </div>
                    <p id="erroValidacaoMensagem" class="text-center"></p>
                </div>
                <div class="modal-footer justify-content-center">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Entendi</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast de Notificação -->
    <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
        <div id="toastSucesso" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="toast-header bg-success text-white">
                <strong class="me-auto">Sucesso</strong>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Fechar"></button>
            </div>
            <div class="toast-body" id="toastMensagem">
                Operação realizada com sucesso!
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="js/sidebar.js"></script>
    
    <script>
        // Variáveis globais
        let currentDate = new Date();
        
        // Inicialização quando o DOM estiver pronto
        // Inicialização principal ocorre mais abaixo (após checagem de auth)
        
        // Funções principais
        function setupEventListeners() {
            // Navegação do calendário
            document.getElementById('prevMonth')?.addEventListener('click', () => {
                currentDate.setMonth(currentDate.getMonth() - 1);
                renderCalendar();
            });
            
            document.getElementById('nextMonth')?.addEventListener('click', () => {
                currentDate.setMonth(currentDate.getMonth() + 1);
                renderCalendar();
            });
            
            document.getElementById('currentMonth')?.addEventListener('click', () => {
                // Ao clicar no currentMonth, alternar o picker de mês/ano
                const picker = document.getElementById('monthPicker');
                const monthSelect = document.getElementById('monthSelect');
                const yearInput = document.getElementById('yearInput');
                if (!picker || !monthSelect || !yearInput) return;

                // preencher com mês/ano atuais
                monthSelect.value = String(currentDate.getMonth());
                yearInput.value = currentDate.getFullYear();

                // alternar visibilidade
                if (picker.classList.contains('d-none')) {
                    picker.classList.remove('d-none');
                    picker.focus();
                } else {
                    picker.classList.add('d-none');
                }
            });

            // Handlers do monthPicker
            document.getElementById('monthPickerCancel')?.addEventListener('click', (e) => {
                e.preventDefault();
                document.getElementById('monthPicker')?.classList.add('d-none');
            });

            document.getElementById('monthPickerGo')?.addEventListener('click', (e) => {
                e.preventDefault();
                const month = parseInt(document.getElementById('monthSelect').value, 10);
                const year = parseInt(document.getElementById('yearInput').value, 10);
                if (!isNaN(month) && !isNaN(year)) {
                    currentDate.setFullYear(year, month, 1);
                    document.getElementById('monthPicker')?.classList.add('d-none');
                    renderCalendar();
                }
            });

            // Fechar picker ao clicar fora
            document.addEventListener('click', (ev) => {
                const picker = document.getElementById('monthPicker');
                const btn = document.getElementById('currentMonth');
                if (!picker || !btn) return;
                const target = ev.target;
                if (picker.classList.contains('d-none')) return;
                if (btn.contains(target) || picker.contains(target)) return; // clique dentro
                picker.classList.add('d-none');
            });
            
            // Botão de novo agendamento
            document.getElementById('newAgendamentoBtn')?.addEventListener('click', () => {
                const modal = bootstrap.Modal.getOrCreateInstance(document.getElementById('agendamentoModal'));
                const form = document.getElementById('agendamentoForm');
                form.reset();
                
                // Definir data e hora atuais
                const now = new Date();
                const formattedDate = now.toISOString().split('T')[0];
                const formattedTime = now.getHours().toString().padStart(2, '0') + ':' + 
                                   now.getMinutes().toString().padStart(2, '0');
                
                // Preencher os campos de data e hora
                document.getElementById('data').value = formattedDate;
                document.getElementById('horaInicio').value = formattedTime;
                
                // Limpar o ID do agendamento (para garantir que é um novo)
                document.getElementById('agendamentoId').value = '';
                
                // Disparar evento de mudança para preencher outros campos se necessário
                document.getElementById('data').dispatchEvent(new Event('change'));
                document.getElementById('horaInicio').dispatchEvent(new Event('change'));
                
                modal.show();
            });
            
            // Envio do formulário: o listener é registrado na inicialização principal (após checkAuth)
            
            // Botão de confirmação de cancelamento
            document.getElementById('btnConfirmarCancelamento')?.addEventListener('click', confirmarCancelamento);
        }
        
        // loadInitialData definido mais abaixo com lógica completa (carrega via API e autenticação)
        
        // Funções auxiliares
        function formatDate(date) {
            return new Intl.DateTimeFormat('pt-BR').format(date);
        }
        
        function formatTime(date) {
            return date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        }
        
        function showToast(message, isError = false) {
            const toastElement = document.getElementById('toastSucesso');
            const toastBody = document.getElementById('toastMensagem');
            
            if (isError) {
                toastElement.classList.remove('bg-success');
                toastElement.classList.add('bg-danger');
                document.querySelector('#toastSucesso .me-auto').textContent = 'Erro';
            } else {
                toastElement.classList.remove('bg-danger');
                toastElement.classList.add('bg-success');
                document.querySelector('#toastSucesso .me-auto').textContent = 'Sucesso';
            }
            
            toastBody.textContent = message;
            const toast = new bootstrap.Toast(toastElement);
            toast.show();
        }

        // Função para exibir mensagem de erro em modal
        function showErrorModal(message) {
            const errorModal = new bootstrap.Modal(document.getElementById('erroValidacaoModal'));
            const errorMessage = document.getElementById('erroValidacaoMensagem');
            errorMessage.textContent = message;
            errorModal.show();
        }
        
        // Funções de manipulação do calendário
        function renderCalendar() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            
            // Atualizar o cabeçalho do mês/ano
            const monthNames = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho",
                              "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];
            document.getElementById('currentMonthText').textContent = `${monthNames[month]} ${year}`;
            
            // Obter o primeiro dia do mês e o último dia do mês
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            
            // Obter o dia da semana do primeiro dia (0 = Domingo, 1 = Segunda, etc.)
            const firstDayIndex = firstDay.getDay();
            
            // Criar array de dias do mês
            let days = [];
            
            // Adicionar dias vazios no início, se necessário
            for (let i = 0; i < firstDayIndex; i++) {
                days.push({ day: '', isCurrentMonth: false });
            }
            
            // Adicionar os dias do mês
            for (let i = 1; i <= lastDay.getDate(); i++) {
                days.push({
                    day: i,
                    isCurrentMonth: true,
                    date: new Date(year, month, i)
                });
            }
            
            // Preencher o calendário
            const calendarDays = document.getElementById('calendarDays');
            if (calendarDays) {
                calendarDays.innerHTML = '';
                
                days.forEach((day, index) => {
                    const dayElement = document.createElement('div');
                    dayElement.className = 'calendar-day';
                    
                    if (day.isCurrentMonth) {
                        dayElement.textContent = day.day;
                        dayElement.addEventListener('click', () => selectDate(day.date));
                        
                        // Destacar o dia atual
                        const today = new Date();
                        if (day.date.toDateString() === today.toDateString()) {
                            dayElement.classList.add('today');
                        }
                    } else {
                        dayElement.classList.add('text-muted');
                    }
                    
                    calendarDays.appendChild(dayElement);
                });
            }
        }
        
        function selectDate(date) {
            // Implementar lógica de seleção de data
            console.log('Data selecionada:', date);
            updateSelectedDate(date);
            loadAppointmentsForDate(date);
        }
        
        function updateSelectedDate(date = new Date()) {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            const formattedDate = date.toLocaleDateString('pt-BR', options);
            const selectedDateElement = document.getElementById('selectedDate');
            
            if (selectedDateElement) {
                selectedDateElement.textContent = formattedDate.charAt(0).toUpperCase() + 
                                               formattedDate.slice(1);
            }
        }
        
        // Funções auxiliares para status
        function getStatusText(status) {
            if (!status) return 'Agendado';
            const statusMap = {
                'AGENDADO': 'Agendado',
                'CONFIRMADO': 'Confirmado',
                'CANCELADO': 'Cancelado',
                'FINALIZADO': 'Finalizado',
                'EM_ANDAMENTO': 'Em andamento',
                'FALTOU': 'Paciente não compareceu'
            };
            return statusMap[status.toUpperCase()] || status;
        }

        function getStatusBadgeIcon(status) {
            if (!status) return '<i class="bi bi-calendar-check"></i>';
            
            const iconMap = {
                'AGENDADO': 'bi-calendar-check',
                'CONFIRMADO': 'bi-check-circle',
                'CANCELADO': 'bi-x-circle',
                'FINALIZADO': 'bi-check-circle-fill',
                'EM_ANDAMENTO': 'bi-arrow-repeat',
                'FALTOU': 'bi-person-x'
            };
            
            const iconClass = iconMap[status.toUpperCase()] || 'bi-question-circle';
            return `<i class="bi ${iconClass}"></i>`;
        }

        // Função para escapar caracteres HTML
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return unsafe;
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Mapa de profissionais por ID e helpers
        let professionalsById = {};
        function buildProfessionalsMapFromSelect() {
            const sel = document.getElementById('profissionalId');
            if (!sel) return;
            professionalsById = {};
            Array.from(sel.options).forEach(opt => {
                const val = (opt.value || '').trim();
                const label = (opt.textContent || '').trim();
                if (val) professionalsById[val] = label;
            });
        }
        function getProfessionalNameById(id) {
            if (!id && id !== 0) {
                console.log('ID do profissional não fornecido');
                return '';
            }
            
            const key = String(id);
            
            // Se não tivermos o mapa de profissionais, tenta construir
            if (!professionalsById || Object.keys(professionalsById).length === 0) {
                console.log('Construindo mapa de profissionais...');
                buildProfessionalsMapFromSelect();
            }
            
            console.log(`Buscando profissional com ID: ${key}`);
            console.log('Profissionais disponíveis:', professionalsById);
            
            const nome = professionalsById[key] || '';
            console.log(`Nome encontrado para ID ${key}:`, nome || 'Nenhum');
            
            return nome;
        }

        // Funções de formatação de data/hora
        function formatDate(date) {
            if (!date) return '';
            
            const d = new Date(date);
            if (isNaN(d.getTime())) return '';
            
            const day = d.getDate().toString().padStart(2, '0');
            const month = (d.getMonth() + 1).toString().padStart(2, '0');
            const year = d.getFullYear();
            
            return `${day}/${month}/${year}`;
        }
        
        function formatTime(date) {
            if (!date) return '';
            const d = new Date(date);
            if (isNaN(d.getTime())) return '';
            
            // Usar os métodos locais já que já ajustamos o fuso horário
            const hours = d.getHours().toString().padStart(2, '0');
            const minutes = d.getMinutes().toString().padStart(2, '0');
            
            return `${hours}:${minutes}`;
        }

        // Funções de manipulação de agendamentos
        
        // Função para editar um agendamento
        function editarAgendamento(id) {
            // Lógica de edição será implementada aqui
        }

        function updateAppointmentsList(appointments) {
            const loadingEl = document.getElementById('appointmentsLoading');
            const emptyEl = document.getElementById('appointmentsEmpty');
            const container = document.getElementById('appointmentsContainer');

            if (!container || !loadingEl || !emptyEl) return;

            loadingEl.classList.add('d-none');

            if (!appointments || appointments.length === 0) {
                container.classList.add('d-none');
                emptyEl.classList.remove('d-none');
                container.innerHTML = '';
                return;
            }

            emptyEl.classList.add('d-none');
            container.classList.remove('d-none');
            
            let html = '';

            // Ordenar agendamentos por data/hora
            const sortedAppointments = [...appointments].sort((a, b) => {
                return (a.dataHora || 0) - (b.dataHora || 0);
            });

            sortedAppointments.forEach(appt => {
                if (!appt.dataHora) return;

                // Log para depuração
                console.log('Estrutura completa do appt:', JSON.parse(JSON.stringify(appt)));
                console.log('Profissional:', appt.profissional);
                console.log('Profissional ID:', appt.profissionalId || appt.profissional_id);
                
                const time = formatTime(appt.dataHora);
                const statusClass = `status-${(appt.status || 'AGENDADO').toString().toUpperCase()}`;
                const statusText = getStatusText(appt.status || 'AGENDADO');
                
                html += `
                    <div class="list-group-item list-group-item-action ${statusClass}" data-appointment-id="${appt.id}">
                        <div class="d-flex w-100 justify-content-between align-items-center">
                            <div class="d-flex align-items-center">
                                <div class="me-3 text-center" style="min-width: 60px">
                                    <div class="fw-bold fs-5">${time}</div>
                                    <small class="text-muted">${formatDate(appt.dataHora)}</small>
                                </div>
                                <div>
                                <h6 class="mb-1">${escapeHtml(appt.cliente || 'Cliente não informado')}</h6>
                                <p class="mb-1"><strong>Profissional:</strong> 
                                    ${(() => {
                                        // Tenta obter o nome do profissional de várias fontes
                                        const nomeProfissional = 
                                            (appt.profissional && (appt.profissional.nome || appt.profissional.name)) ||
                                            appt.profissionalNome || 
                                            appt.nomeProfissional ||
                                            (appt.profissionalId ? getProfessionalNameById(appt.profissionalId) : '') ||
                                            (appt.profissional_id ? getProfessionalNameById(appt.profissional_id) : '') ||
                                            'Não informado';
                                        return escapeHtml(nomeProfissional);
                                    })()}
                                </p>
                                <p class="mb-1">${escapeHtml(appt.procedimento || 'Procedimento não informado')}</p>
                                </div>
                            </div>
                            <div class="d-flex align-items-center">
                                <span class="status-badge ${statusClass} me-2">
                                    ${getStatusBadgeIcon(appt.status || 'AGENDADO')} ${statusText}
                                </span>
                                <div class="action-buttons btn-group">
                                    <button class="btn btn-sm btn-outline-primary me-1" 
                                            onclick="editAppointment('${appt.id}')"
                                            data-bs-toggle="tooltip" 
                                            title="Editar agendamento">
                                        <i class="bi bi-pencil"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-success me-1" 
                                            onclick="finalizeAppointment('${appt.id}')"
                                            ${appt.status === 'FINALIZADO' ? 'disabled' : ''}
                                            data-bs-toggle="tooltip" 
                                            title="Finalizar agendamento">
                                        <i class="bi bi-check-lg"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger" 
                                            onclick="cancelAppointment('${appt.id}')"
                                            ${appt.status === 'CANCELADO' ? 'disabled' : ''}
                                            data-bs-toggle="tooltip" 
                                            title="Cancelar agendamento">
                                        <i class="bi bi-x-lg"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>`;
            });

            container.innerHTML = html || '<div class="p-3 text-center text-muted">Nenhum agendamento para exibir</div>';
            
            // Atualizar tooltips do Bootstrap
            const tooltipTriggerList = [].slice.call(container.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.forEach(function (tooltipTriggerEl) {
                try {
                    new bootstrap.Tooltip(tooltipTriggerEl);
                } catch (e) {
                    // Ignorar erros de tooltip
                }
            });
        }
        
        // Variável para controlar a data atual na lista
        let currentListDate = new Date();
        
        // Função para formatar a data como YYYY-MM-DD
        function formatDateForFilter(date) {
            const d = new Date(date);
            return d.toISOString().split('T')[0];
        }
        
        // Função para filtrar agendamentos por data
        function filterAppointmentsByDate(date, appointmentsList = []) {
            if (!appointmentsList || !appointmentsList.length) {
                console.log('Nenhum agendamento disponível para filtrar');
                return [];
            }
            
            const dateStr = formatDateForFilter(date);
            console.log(`Filtrando agendamentos para a data: ${dateStr}`);
            
            const filtered = appointmentsList.filter(appt => {
                if (!appt || !appt.dataHora) return false;
                const apptDate = formatDateForFilter(appt.dataHora);
                return apptDate === dateStr;
            });
            
            console.log(`Encontrados ${filtered.length} agendamentos para ${dateStr}`);
            return filtered;
        }
        
        // Função para formatar a data no formato DD/MM/AAAA
        function formatDisplayDate(date) {
            const targetDate = new Date(date);
            
            // Formata como DD/MM/AAAA
            return targetDate.toLocaleDateString('pt-BR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
            });
        }
        
        // Função para verificar se uma data é hoje
        function isToday(date) {
            const today = new Date();
            return date.toDateString() === today.toDateString();
        }
        
        // Função para atualizar a exibição da data
        function updateDateDisplay(date) {
            const dateDisplay = document.getElementById('currentDateDisplay');
            const dateContainer = document.getElementById('dateDisplayContainer');
            
            if (dateDisplay && dateContainer) {
                // Adiciona estilo se for hoje
                if (isToday(date)) {
                    dateContainer.style.backgroundColor = '#e9ecef';
                    dateContainer.style.borderColor = '#0d6efd';
                    dateDisplay.style.color = '#0d6efd';
                } else {
                    dateContainer.style.backgroundColor = '#fff';
                    dateContainer.style.borderColor = '#dee2e6';
                    dateDisplay.style.color = '#212529';
                }
                
                dateDisplay.textContent = formatDisplayDate(date);
            }
        }
        
        // Função para mostrar/ocultar o indicador de carregamento
        function showLoading(show = true) {
            const loadingElement = document.getElementById('loadingRow');
            if (loadingElement) {
                loadingElement.style.display = show ? 'table-row' : 'none';
            }
        }
        
        // Configurar os botões de navegação
        document.addEventListener('DOMContentLoaded', function() {
            // Função para navegar para um dia específico
            async function goToDate(date, showLoadingIndicator = true) {
                currentListDate = new Date(date);
                await updateTableForDate(currentListDate, showLoadingIndicator);
                updateDateDisplay(currentListDate);
            }
            
            // Botão Anterior
            document.getElementById('prevDay').addEventListener('click', async function() {
                const newDate = new Date(currentListDate);
                newDate.setDate(newDate.getDate() - 1);
                await goToDate(newDate, true);
            });
            
            // Botão Hoje
            document.getElementById('todayBtn').addEventListener('click', async function() {
                await goToDate(new Date(), true);
            });
            
            // Botão Próximo
            document.getElementById('nextDay').addEventListener('click', async function() {
                const newDate = new Date(currentListDate);
                newDate.setDate(newDate.getDate() + 1);
                await goToDate(newDate, true);
            });
            
            // Inicializa a tabela com a data atual (sem mostrar o spinner inicial)
            goToDate(new Date(), false);
            
            // Configura o evento de mudança de aba
            const listTab = document.getElementById('list-tab');
            if (listTab) {
                listTab.addEventListener('shown.bs.tab', async function() {
                    // Se a tabela já foi carregada alguma vez, não mostra o spinner
                    const tbody = document.getElementById('appointmentsTableBody');
                    if (tbody && tbody.querySelector('tr:not(#emptyAppointmentsRow):not(#loadingRow)')) {
                        return;
                    }
                    // Se não há itens carregados, força o recarregamento com spinner
                    await goToDate(currentListDate, true);
                });
            }
        });
        
        // Variáveis de paginação
        let currentPage = 1;
        const itemsPerPage = 10; // Número de itens por página
        let totalPages = 1;
        
        // Função para atualizar a paginação
        function updatePagination(totalItems) {
            const paginationContainer = document.getElementById('paginationContainer');
            const paginationList = document.getElementById('paginationList');
            
            // Calcular o número total de páginas
            totalPages = Math.ceil(totalItems / itemsPerPage);
            
            // Mostrar ou esconder a paginação com base no número de páginas
            if (totalPages <= 1) {
                paginationContainer.style.display = 'none';
                return;
            }
            
            paginationContainer.style.display = 'block';
            paginationList.innerHTML = '';
            
            // Botão Anterior
            const prevLi = document.createElement('li');
            prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
            prevLi.innerHTML = `
                <a class="page-link" href="#" ${currentPage === 1 ? 'tabindex="-1" aria-disabled="true"' : ''}>
                    Anterior
                </a>
            `;
            prevLi.addEventListener('click', (e) => {
                e.preventDefault();
                if (currentPage > 1) {
                    currentPage--;
                    updateTableForDate(currentListDate);
                }
            });
            paginationList.appendChild(prevLi);
            
            // Números das páginas
            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            
            // Primeira página
            if (startPage > 1) {
                const firstLi = document.createElement('li');
                firstLi.className = 'page-item';
                firstLi.innerHTML = '<a class="page-link" href="#">1</a>';
                firstLi.addEventListener('click', (e) => {
                    e.preventDefault();
                    currentPage = 1;
                    updateTableForDate(currentListDate);
                });
                paginationList.appendChild(firstLi);
                
                if (startPage > 2) {
                    const ellipsisLi = document.createElement('li');
                    ellipsisLi.className = 'page-item disabled';
                    ellipsisLi.innerHTML = '<span class="page-link">...</span>';
                    paginationList.appendChild(ellipsisLi);
                }
            }
            
            // Páginas do meio
            for (let i = startPage; i <= endPage; i++) {
                const pageLi = document.createElement('li');
                pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
                pageLi.innerHTML = `<a class="page-link" href="#">${i}</a>`;
                
                if (i !== currentPage) {
                    pageLi.addEventListener('click', (e) => {
                        e.preventDefault();
                        currentPage = i;
                        updateTableForDate(currentListDate);
                    });
                }
                
                paginationList.appendChild(pageLi);
            }
            
            // Última página
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    const ellipsisLi = document.createElement('li');
                    ellipsisLi.className = 'page-item disabled';
                    ellipsisLi.innerHTML = '<span class="page-link">...</span>';
                    paginationList.appendChild(ellipsisLi);
                }
                
                const lastLi = document.createElement('li');
                lastLi.className = 'page-item';
                lastLi.innerHTML = `<a class="page-link" href="#">${totalPages}</a>`;
                lastLi.addEventListener('click', (e) => {
                    e.preventDefault();
                    currentPage = totalPages;
                    updateTableForDate(currentListDate);
                });
                paginationList.appendChild(lastLi);
            }
            
            // Botão Próximo
            const nextLi = document.createElement('li');
            nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
            nextLi.innerHTML = `
                <a class="page-link" href="#" ${currentPage === totalPages ? 'tabindex="-1" aria-disabled="true"' : ''}>
                    Próximo
                </a>
            `;
            nextLi.addEventListener('click', (e) => {
                e.preventDefault();
                if (currentPage < totalPages) {
                    currentPage++;
                    updateTableForDate(currentListDate);
                }
            });
            paginationList.appendChild(nextLi);
        }
        
        // Função para obter os itens da página atual
        function getPaginatedItems(items) {
            const startIndex = (currentPage - 1) * itemsPerPage;
            return items.slice(startIndex, startIndex + itemsPerPage);
        }
        
        // Atualizar a função updateTableForDate para suportar paginação
        async function clearTable() {
            const tbody = document.getElementById('appointmentsTableBody');
            if (!tbody) return;
            
            // Remove todos os itens da tabela, exceto as linhas de loading e mensagem vazia
            const rows = tbody.querySelectorAll('tr:not(#emptyAppointmentsRow):not(#loadingRow)');
            rows.forEach(row => row.remove());
            
            // Esconde a mensagem de vazio
            const emptyRow = document.getElementById('emptyAppointmentsRow');
            if (emptyRow) emptyRow.classList.add('d-none');
        }
        
        async function updateTableForDate(date, showLoadingIndicator = true) {
            const tbody = document.getElementById('appointmentsTableBody');
            const emptyRow = document.getElementById('emptyAppointmentsRow');
            const listTab = document.getElementById('list-tab');
            
            // Só faz algo se estivermos na aba de lista
            if (!listTab || !listTab.classList.contains('active')) return;
            
            try {
                currentListDate = new Date(date);
                
                // Limpa a tabela antes de começar o carregamento
                await clearTable();
                
                // Mostra o spinner de carregamento apenas se solicitado
                if (showLoadingIndicator) {
                    showLoading(true);
                }
                
                // Carregar os agendamentos da API para a data selecionada
                const appointments = await loadAppointmentsForDate(currentListDate);
                
                // Resetar para a primeira página ao mudar de data
                currentPage = 1;
                
                // Atualizar a tabela diretamente com todos os agendamentos
                updateAppointmentsTable(appointments);
                
                // Atualizar a paginação
                updatePagination(appointments.length);
                
                // Rolar para o topo da tabela
                document.querySelector('#list-tab-pane .table-responsive')?.scrollIntoView({ behavior: 'smooth' });
                
            } catch (error) {
                console.error('Erro ao carregar agendamentos:', error);
                showToast('Erro ao carregar agendamentos para a data selecionada', true);
                // Força a exibição da mensagem de lista vazia em caso de erro
                updateAppointmentsTable([]);
            } finally {
                // Garante que o spinner seja escondido mesmo em caso de erro
                showLoading(false);
            }
        }
        
        // As funções reais para carregar clientes/procedimentos via API estão definidas mais abaixo
        
        // Funções auxiliares de interface
        function getStatusBadgeIcon(status) {
            const icons = {
                'AGENDADO': 'bi-calendar-check',
                'EM_ANDAMENTO': 'bi-hourglass-split',
                'FINALIZADO': 'bi-check2-all',
                'CANCELADO': 'bi-x-circle'
            };
            
            return `<i class="bi ${icons[status] || 'bi-question-circle'}"></i>`;
        }
        
        function getStatusText(status) {
            const statusMap = {
                'AGENDADO': 'Agendado',
                'EM_ANDAMENTO': 'Em Andamento',
                'FINALIZADO': 'Finalizado',
                'CANCELADO': 'Cancelado'
            };
            

    container.innerHTML = html || '<div class="p-3 text-center text-muted">Nenhum agendamento para exibir</div>';
            
    // Atualizar tooltips do Bootstrap
    const tooltipTriggerList = [].slice.call(container.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(function (tooltipTriggerEl) {
        try {
            new bootstrap.Tooltip(tooltipTriggerEl);
        } catch (e) {
            // Ignorar erros de tooltip
        }
    });
}

function showLoading(show = true) {
    const loadingRow = document.getElementById('loadingRow');
    if (loadingRow) {
        const loadingCell = loadingRow.querySelector('td');
        if (show) {
            loadingRow.classList.remove('d-none');
            loadingCell.classList.remove('d-none');
        } else {
            loadingRow.classList.add('d-none');
            loadingCell.classList.add('d-none');
        }
    }
}

function updateAppointmentsTable(appointments) {
    const tbody = document.getElementById('appointmentsTableBody');
    const emptyRow = document.getElementById('emptyAppointmentsRow');
    const listTab = document.getElementById('list-tab');
    
    // Só faz algo se estivermos na aba de lista
    if (!listTab || !listTab.classList.contains('active') || !tbody) return;
    
    // Remove todos os itens da tabela, exceto as linhas de loading e mensagem vazia
    const rows = tbody.querySelectorAll('tr:not(#emptyAppointmentsRow):not(#loadingRow)');
    rows.forEach(row => row.remove());
    
    // Esconde o loading
    showLoading(false);
    
    // Se não houver agendamentos, mostra a mensagem e retorna
    if (!appointments || appointments.length === 0) {
        if (emptyRow) emptyRow.classList.remove('d-none');
        return;
    }
    
    // Esconde a mensagem de vazio
    if (emptyRow) emptyRow.classList.add('d-none');
    
    // Adiciona os agendamentos à tabela
    appointments.forEach(appt => {
        const row = document.createElement('tr');
        const statusClass = `status-${appt.status}`;
        const professional = appt.profissional || appt.professional || appt.profissionalNome || appt.nomeProfissional || '';
                
        row.innerHTML = `
            <td>${formatDate(appt.dataHora)} ${formatTime(appt.dataHora)}</td>
            <td>${appt.cliente}</td>
            <td>${
                (appt.profissional || appt.professional || appt.profissionalNome || appt.nomeProfissional ||
                 getProfessionalNameById(appt.profissionalId || appt.profissional_id || appt.professionalId || appt.professional_id)) || ''
            }</td>
            <td>${appt.procedimento}</td>
            <td><span class="status-badge ${statusClass}">${getStatusText(appt.status)}</span></td>
            <td class="text-end">
                <div class="action-buttons justify-content-end">
                    <button class="btn btn-sm btn-outline-success" 
                            onclick="finalizeAppointment(${appt.id})" 
                            ${appt.status === 'finalizado' ? 'disabled' : ''}
                            data-bs-toggle="tooltip" 
                            data-bs-placement="top" 
                            title="Finalizar">
                        <i class="bi bi-check-lg"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-primary" 
                            onclick="editAppointment(${appt.id})"
                            data-bs-toggle="tooltip" 
                            data-bs-placement="top" 
                            title="Editar">
                        <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-danger" 
                            onclick="cancelAppointment(${appt.id})" 
                            ${appt.status === 'finalizado' ? 'disabled' : ''}
                            data-bs-toggle="tooltip" 
                            data-bs-placement="top" 
                            title="Cancelar">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
            </td>
        `;
                
        tbody.appendChild(row);
    });
}

// As funções reais para carregar clientes/procedimentos via API estão definidas mais abaixo
        
// Funções auxiliares de interface
function getStatusBadgeIcon(status) {
    const icons = {
        'pendente': 'bi-hourglass-split',
        'confirmado': 'bi-check-circle',
        'cancelado': 'bi-x-circle',
        'finalizado': 'bi-check2-all'
    };
            
    return `<i class="bi ${icons[status] || 'bi-question-circle'}"></i>`;
}

function getStatusText(status) {
    const statusMap = {
        'pendente': 'Pendente',
        'confirmado': 'Confirmado',
        'cancelado': 'Cancelado',
        'finalizado': 'Finalizado'
    };
            
    return statusMap[status] || status;
}

// Funções globais para acesso via HTML
window.editAppointment = async function(id) {
    const loadingToast = showToast('Carregando agendamento...', false, 0); // Toast sem timeout
            
    try {
        console.log('Buscando detalhes do agendamento:', id);
                
        // Buscar os dados reais do agendamento
        const response = await fetchWithAuth(`/api/agendamentos/${id}`);
        if (!response || !response.ok) {
            throw new Error('Erro ao buscar agendamento: ' + (response?.statusText || 'Sem resposta do servidor'));
        }

        const payload = await response.json();
        // API pode retornar { success: true, data: {...} } ou diretamente o objeto
        const agendamento = (payload && payload.success && payload.data) ? payload.data : payload;
        console.log('Dados do agendamento (normalized):', agendamento);

        // Converter as datas para o formato correto
        const safeParseDate = (v) => {
            if (!v) return null;
            try {
                const d = new Date(v);
                if (isNaN(d.getTime())) return null;
                return d;
            } catch (e) {
                console.warn('Erro ao fazer parse da data:', v, e);
                return null;
            }
        };

        // Tentar obter a data de início de várias fontes possíveis
        let startDate = safeParseDate(agendamento.startTime || agendamento.start_time);
        if (!startDate && agendamento.data) {
            const dateStr = agendamento.data;
            const timeStr = agendamento.horaInicio || '00:00';
            startDate = safeParseDate(`${dateStr}T${timeStr}:00`);
        }

        // Calcular duração
        const endDate = safeParseDate(agendamento.endTime || agendamento.end_time);
        let durationMinutes = agendamento.duracao || 30;
                
        if (startDate && endDate) {
            const durationMs = endDate - startDate;
            durationMinutes = Math.max(1, Math.floor(durationMs / (1000 * 60)));
        }
                
        // Preencher o formulário
        const modalEl = document.getElementById('agendamentoModal');
        const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
        const form = document.getElementById('agendamentoForm');
                
        // Resetar o formulário
        form.reset();
                
        // Preencher campos básicos
        form.querySelector('[name="agendamentoId"]').value = agendamento.id || '';
                
        // Preencher selects com valores atuais
        const fillSelect = (id, value) => {
            const select = document.getElementById(id);
            if (select && value !== undefined && value !== null) {
                const option = Array.from(select.options).find(opt => opt.value == value);
                if (option) {
                    select.value = value;
                } else {
                    console.warn(`Valor não encontrado no select ${id}:`, value);
                }
            }
        };
                
        fillSelect('clienteId', agendamento.clienteId);
        fillSelect('procedimentoId', agendamento.procedimentoId);
        fillSelect('profissionalId', agendamento.profissionalId);
                
        // Preencher data e hora
        if (startDate) {
            // Ajustar para o fuso horário local
            const localDate = new Date(startDate.getTime() - (startDate.getTimezoneOffset() * 60000));
            document.getElementById('data').value = localDate.toISOString().split('T')[0];
            document.getElementById('horaInicio').value = 
                String(startDate.getHours()).padStart(2, '0') + ':' + 
                String(startDate.getMinutes()).padStart(2, '0');
        }
                
        // Preencher demais campos
        document.getElementById('duracao').value = durationMinutes;
        document.getElementById('valorCobrado').value = agendamento.valorCobrado || '';
        document.getElementById('observacoes').value = agendamento.observacoes || '';
                
        // Disparar eventos de mudança para atualizar campos dependentes
        ['data', 'horaInicio', 'procedimentoId'].forEach(field => {
            const el = document.getElementById(field);
            if (el) {
                try {
                    el.dispatchEvent(new Event('change'));
                } catch(e) {
                    console.warn(`Erro ao disparar evento change em ${field}:`, e);
                }
            }
        });

        // Mostrar o modal
        modal.show();
        
        // Fechar o toast de carregamento
        if (loadingToast && loadingToast.hide) loadingToast.hide();
        
    } catch (error) {
        console.error('Erro ao carregar agendamento:', error);
        showErrorModal('Erro ao carregar agendamento: ' + (error.message || 'Tente novamente'));
        if (loadingToast && loadingToast.hide) loadingToast.hide();
    }
};

        window.finalizeAppointment = async function(id) {
            try {
                if (!id) {
                    throw new Error('ID do agendamento não informado');
                }

                // Mostrar toast de carregamento
                const loadingToast = showToast('Finalizando agendamento...', false, true);
                
                // Enviar requisição para atualizar o status do agendamento
                const response = await fetchWithAuth(`/api/agendamentos/${id}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        status: 'FINALIZADO',
                        // Incluir outros campos necessários para evitar validações
                        data: new Date().toISOString().split('T')[0],
                        horaInicio: '00:00',
                        horaFim: '23:59',
                        procedimentoId: 1 // ID padrão, será sobrescrito pelo backend
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || 'Erro ao finalizar agendamento');
                }

                // Fechar o toast de carregamento
                if (loadingToast && loadingToast.hide) loadingToast.hide();
                
                showToast('Agendamento finalizado com sucesso!');
                
                // Recarregar os agendamentos
                const selectedDate = currentDate || new Date();
                loadAppointmentsForDate(selectedDate);
                
            } catch (error) {
                console.error('Erro ao finalizar agendamento:', error);
                showErrorModal('Erro ao finalizar agendamento: ' + (error.message || 'Tente novamente'));
            }
        };

        window.cancelAppointment = function(id) {
            try {
                if (!id) {
                    throw new Error('ID do agendamento não informado');
                }
                
                // Armazenar o ID no modal
                const confirmId = document.getElementById('confirmarCancelamentoId');
                if (!confirmId) {
                    throw new Error('Elemento de confirmação não encontrado');
                }
                
                confirmId.value = id;
                
                // Atualizar a mensagem do modal com o ID
                const modalMessage = document.getElementById('confirmarCancelamentoMessage');
                if (modalMessage) {
                    modalMessage.textContent = `Tem certeza que deseja cancelar o agendamento #${id}?`;
                }
                
                // Mostrar o modal de confirmação
                const modal = new bootstrap.Modal(document.getElementById('confirmarCancelamentoModal'), {
                    backdrop: 'static',
                    keyboard: false
                });
                modal.show();
                
                // Focar no botão de confirmação para melhor acessibilidade
                setTimeout(() => {
                    const confirmBtn = document.getElementById('btnConfirmarCancelamento');
                    if (confirmBtn) confirmBtn.focus();
                }, 100);
                
            } catch (error) {
                console.error('Erro ao iniciar cancelamento:', error);
                showErrorModal('Erro ao preparar o cancelamento: ' + (error.message || 'Tente novamente'));
            }
        };
        
        async function confirmarCancelamento() {
            const id = document.getElementById('confirmarCancelamentoId')?.value;
            const btnConfirmar = document.getElementById('btnConfirmarCancelamento');
            const btnCancelar = document.getElementById('btnCancelarCancelamento');
            
            // Desabilitar botões durante o processamento
            if (btnConfirmar) btnConfirmar.disabled = true;
            if (btnCancelar) btnCancelar.disabled = true;
            
            try {
                if (!id) {
                    throw new Error('ID do agendamento não informado');
                }
                
                // Mostrar loading
                const loadingToast = showToast('Cancelando agendamento...', false, 0);
                
                // Chamar a API para cancelar o agendamento
                const response = await fetchWithAuth(`/api/agendamentos/${id}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                // Fechar o toast de loading
                if (loadingToast && loadingToast.hide) loadingToast.hide();
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || 'Erro ao cancelar agendamento');
                }
                
                // Fechar o modal de confirmação
                const modal = bootstrap.Modal.getInstance(document.getElementById('confirmarCancelamentoModal'));
                if (modal) modal.hide();
                
                // Recarregar os agendamentos
                await loadAppointmentsForDate(currentDate);
                
                // Mostrar mensagem de sucesso
                showToast('Agendamento cancelado com sucesso!', false);
                
            } catch (error) {
                console.error('Erro ao cancelar agendamento:', error);
                showErrorModal('Erro ao cancelar agendamento: ' + (error.message || 'Tente novamente'));
            } finally {
                // Reabilitar botões
                if (btnConfirmar) btnConfirmar.disabled = false;
                if (btnCancelar) btnCancelar.disabled = false;
            }
        }
        
        // Função para carregar dados iniciais
        async function loadInitialData() {
            try {
                await Promise.all([
                    loadClientes(),
                    loadProcedimentos(),
                    loadProfissionais()
                ]);
                
                // Carregar agendamentos para a data atual
                const hoje = new Date();
                loadAppointmentsForDate(hoje);
            } catch (error) {
                console.error('Erro ao carregar dados iniciais:', error);
                showToast('Erro ao carregar dados iniciais. Por favor, recarregue a página.', true);
            }
        }

        // Função para fazer requisições autenticadas
        async function fetchWithAuth(url, options = {}) {
            const token = localStorage.getItem('token');
            if (!token) {
                console.error('Token não encontrado no localStorage');
                window.location.href = '/login';
                return null;
            }

            try {
                console.log(`Fazendo requisição para: ${url}`, { method: options.method || 'GET' });
                
                const defaultHeaders = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                };

                const response = await fetch(url, {
                    ...options,
                    headers: {
                        ...defaultHeaders,
                        ...(options.headers || {})
                    },
                    credentials: 'include' // Importante para cookies de sessão
                });

                console.log(`Resposta de ${url}:`, response.status, response.statusText);

                if (response.status === 401) {
                    console.warn('Token inválido ou expirado, redirecionando para login');
                    localStorage.removeItem('token');
                    window.location.href = '/login';
                    return null;
                }

                if (response.status === 403) {
                    console.error('Acesso negado ao recurso:', url);
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || 'Você não tem permissão para acessar este recurso');
                }

                if (response.status >= 500) {
                    console.error('Erro no servidor ao acessar:', url);
                    throw new Error('Ocorreu um erro no servidor. Por favor, tente novamente mais tarde.');
                }

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Erro na requisição:', response.status, errorData);
                    throw new Error(errorData.message || `Erro na requisição: ${response.statusText}`);
                }

                return response;
            } catch (error) {
                console.error(`Erro na requisição para ${url}:`, error);
                throw error;
            }
        }

        // Função para carregar clientes
        async function loadClientes() {
            try {
                const response = await fetchWithAuth('/api/clientes');
                if (!response) return [];
                const clientes = await response.json();
                
                const select = document.getElementById('clienteId');
                if (!select) return;
                
                // Salvar o valor atual
                const valorAtual = select.value;
                
                // Limpar opções existentes (exceto a primeira)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Adicionar clientes ao select
                clientes.forEach(cliente => {
                    if (cliente && cliente.id) {
                        const option = new Option(
                            cliente.nome || `Cliente ${cliente.id}`,
                            cliente.id
                        );
                        select.add(option);
                    }
                });
                
                // Restaurar o valor anterior, se ainda existir
                if (valorAtual) {
                    select.value = valorAtual;
                }
                
                return clientes;
            } catch (error) {
                console.error('Erro ao carregar clientes:', error);
                showToast('Erro ao carregar clientes', true);
                return [];
            }
        }

        // Função para carregar procedimentos
        async function loadProcedimentos() {
            try {
                console.log('Carregando procedimentos...');
                const response = await fetchWithAuth('/api/procedimentos');
                
                // Verificar se a resposta é válida
                if (!response) {
                    console.error('Resposta vazia da API de procedimentos');
                    return [];
                }
                
                let data = response;
                
                // Se for um objeto Response, extrair o JSON
                if (response instanceof Response) {
                    console.log('Convertendo resposta para JSON...');
                    data = await response.json();
                }
                
                // Verificar se os dados são um array
                if (!Array.isArray(data)) {
                    console.error('Resposta inesperada da API de procedimentos:', data);
                    return [];
                }
                
                console.log(`${data.length} procedimentos recebidos`);
                
                // Obter o elemento select
                const select = document.getElementById('procedimentoId');
                if (!select) {
                    console.error('Elemento select#procedimentoId não encontrado');
                    return [];
                }
                
                // Limpar opções existentes (exceto a primeira)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Adicionar procedimentos ao select
                data.forEach(proc => {
                    if (proc && (proc.id || proc._id)) {
                        const id = proc.id || proc._id;
                        // Usando o campo 'name' que vem da API, com fallback para 'descricao' e depois para um valor padrão
                        let nome = proc.name || proc.descricao || `Procedimento ${id}`;
                        
                        // Remover prefixos mantendo a formatação original
                        if (nome.toLowerCase().startsWith('de ')) {
                            nome = nome.substring(3);
                        } else if (nome.toLowerCase().startsWith('descrição do procedimento')) {
                            nome = nome.substring('descrição do procedimento'.length);
                        }
                        
                        // Remover espaços extras e garantir que a primeira letra seja maiúscula
                        nome = nome.trim();
                        const duracao = proc.durationMins || proc.duracaoMinutos || proc.duracao || 60;
                        const valor = proc.defaultPrice || proc.valor || proc.preco || 0;
                        
                        const option = new Option(nome, id);
                        option.dataset.duracao = duracao;
                        option.dataset.valor = valor;
                        select.add(option);
                        
                        console.log(`Adicionado: ${nome} (ID: ${id}, Duração: ${duracao} min, Valor: R$ ${valor})`);
                    }
                });
                
                // Configurar evento de mudança
                const updateFields = function() {
                    const selectedOption = select.options[select.selectedIndex];
                    if (selectedOption && selectedOption.dataset.duracao) {
                        const duracaoInput = document.getElementById('duracao');
                        if (duracaoInput) duracaoInput.value = selectedOption.dataset.duracao;
                    }
                    if (selectedOption && selectedOption.dataset.valor) {
                        const valorInput = document.getElementById('valorCobrado');
                        if (valorInput) valorInput.value = selectedOption.dataset.valor;
                    }
                };
                
                // Adicionar evento de mudança
                select.removeEventListener('change', updateFields);
                select.addEventListener('change', updateFields);
                
                // Disparar evento de mudança para preencher os campos iniciais
                if (select.options.length > 1) {
                    select.dispatchEvent(new Event('change'));
                }
                
                return response;
                
            } catch (error) {
                console.error('Erro ao carregar procedimentos:', error);
                showToast('Erro ao carregar a lista de procedimentos', true);
                return [];
            }
        }

        // Função para carregar profissionais
        async function loadProfissionais() {
            try {
                console.log('Carregando lista de profissionais...');
                const response = await fetchWithAuth('/api/profissionais/my-professionals');
                
                // Se não houver resposta (usuário redirecionado para login)
                if (!response) {
                    console.log('Usuário não autenticado, redirecionando...');
                    return [];
                }
                
                const result = await response.json();
                console.log('Resposta da API de profissionais:', result);
                
                // A API pode retornar { data: [...], pagination: {...} } ou um array direto
                const profissionais = Array.isArray(result) 
                    ? result 
                    : (Array.isArray(result.data) ? result.data : []);
                    
                console.log(`Profissionais carregados: ${profissionais.length}`, profissionais);
                
                const select = document.getElementById('profissionalId');
                if (!select) {
                    console.warn('Elemento select de profissionais não encontrado');
                    return [];
                }
                
                // Limpar opções existentes (exceto a primeira)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Resetar o mapa de profissionais
                professionalsById = {};
                
                // Adicionar profissionais ao select e ao mapa
                profissionais.forEach(prof => {
                    if (prof) {
                        const id = prof.id || prof._id || '';
                        const nome = prof.nome || prof.name || `Profissional ${id}`;
                        
                        // Adicionar ao select
                        if (id) {
                            const option = new Option(nome, id);
                            // Adicionar dados adicionais como data attributes, se necessário
                            if (prof.especialidade) {
                                option.dataset.especialidade = prof.especialidade;
                            }
                            select.add(option);
                            
                            // Adicionar ao mapa de profissionais
                            professionalsById[id.toString()] = nome;
                        }
                    }
                });
                
                console.log('Mapa de profissionais atualizado:', professionalsById);
                
                // Disparar evento de mudança para preencher os campos iniciais
                if (select.options.length > 1) {
                    select.dispatchEvent(new Event('change'));
                }
                
                return profissionais;
                
    } catch (error) {
        console.error('Erro ao carregar profissionais:', error);
        showToast('Erro ao carregar a lista de profissionais', true);
        return [];
    }
}

// Função para carregar procedimentos
async function loadProcedimentos() {
    try {
        console.log('Carregando procedimentos...');
        const response = await fetchWithAuth('/api/procedimentos');
        
        // Verificar se a resposta é válida
        if (!response) {
            console.error('Resposta vazia da API de procedimentos');
            return [];
        }
        
        let data = response;
        
        // Se for um objeto Response, extrair o JSON
        if (response instanceof Response) {
            console.log('Convertendo resposta para JSON...');
            data = await response.json();
        }
        
        // Verificar se os dados são um array
        if (!Array.isArray(data)) {
            console.error('Resposta inesperada da API de procedimentos:', data);
            return [];
        }
        
        console.log(`${data.length} procedimentos recebidos`);
        
        // Obter o elemento select
        const select = document.getElementById('procedimentoId');
        if (!select) {
            console.error('Elemento select#procedimentoId não encontrado');
            return [];
        }
        
        // Limpar opções existentes (exceto a primeira)
        while (select.options.length > 1) {
            select.remove(1);
        }
        
        // Adicionar procedimentos ao select
        data.forEach(proc => {
            if (proc && (proc.id || proc._id)) {
                const id = proc.id || proc._id;
                // Usando o campo 'name' que vem da API, com fallback para 'descricao' e depois para um valor padrão
                let nome = proc.name || proc.descricao || `Procedimento ${id}`;
                
                // Remover prefixos mantendo a formatação original
                if (nome.toLowerCase().startsWith('de ')) {
                    nome = nome.substring(3);
                } else if (nome.toLowerCase().startsWith('descrição do procedimento')) {
                    nome = nome.substring('descrição do procedimento'.length);
                }
                
                // Remover espaços extras e garantir que a primeira letra seja maiúscula
                nome = nome.trim();
                const duracao = proc.durationMins || proc.duracaoMinutos || proc.duracao || 60;
                const valor = proc.defaultPrice || proc.valor || proc.preco || 0;
                
                const option = new Option(nome, id);
                option.dataset.duracao = duracao;
                option.dataset.valor = valor;
                select.add(option);
                
                console.log(`Adicionado: ${nome} (ID: ${id}, Duração: ${duracao} min, Valor: R$ ${valor})`);
            }
        });
        
        // Configurar evento de mudança
        const updateFields = function() {
            const selectedOption = select.options[select.selectedIndex];
            if (selectedOption && selectedOption.dataset.duracao) {
                const duracaoInput = document.getElementById('duracao');
                if (duracaoInput) duracaoInput.value = selectedOption.dataset.duracao;
            }
            if (selectedOption && selectedOption.dataset.valor) {
                const valorInput = document.getElementById('valorCobrado');
                if (valorInput) valorInput.value = selectedOption.dataset.valor;
            }
        };
        
        // Adicionar evento de mudança
        select.removeEventListener('change', updateFields);
        select.addEventListener('change', updateFields);
        
        // Disparar evento de mudança para preencher os campos iniciais
        if (select.options.length > 1) {
            select.dispatchEvent(new Event('change'));
        }
        
        return response;
        
    } catch (error) {
        console.error('Erro ao carregar procedimentos:', error);
        showToast('Erro ao carregar a lista de procedimentos', true);
        return [];
    }
}

// Função para carregar profissionais
async function loadProfissionais() {
    try {
        console.log('Carregando lista de profissionais...');
        const response = await fetchWithAuth('/api/profissionais/my-professionals');
        
        // Se não houver resposta (usuário redirecionado para login)
        if (!response) {
            console.log('Usuário não autenticado, redirecionando...');
            return [];
        }
        
        const result = await response.json();
        // A API retorna { data: [...], pagination: {...} }
        const profissionais = Array.isArray(result) ? result : (Array.isArray(result.data) ? result.data : []);
        console.log('Profissionais carregados:', profissionais.length);
        
        const select = document.getElementById('profissionalId');
        if (!select) {
            console.warn('Elemento select de profissionais não encontrado');
            return [];
        }
        
        // Limpar opções existentes (exceto a primeira)
        while (select.options.length > 1) {
            select.remove(1);
        }
        
        // Adicionar profissionais ao select
        profissionais.forEach(prof => {
            if (prof && (prof.id || prof._id)) {
                const id = prof.id || prof._id;
                const nome = prof.nome || prof.name || `Profissional ${id}`;
                
                const option = new Option(nome, id);
                // Adicionar dados adicionais como data attributes, se necessário
                if (prof.especialidade) {
                    option.dataset.especialidade = prof.especialidade;
                }
                select.add(option);
            }
        });
        
        // Disparar evento de mudança para preencher os campos iniciais
        if (select.options.length > 1) {
            select.dispatchEvent(new Event('change'));
        }
        
        return profissionais;
        
    } catch (error) {
        console.error('Erro ao carregar profissionais:', error);
        showToast('Erro ao carregar a lista de profissionais', true);
        return [];
    }
}

// Função para formatar data e hora para o formato ISO 8601
function formatDateTime(dateStr, timeStr) {
    try {
        if (!dateStr || !timeStr) {
            console.error('Data ou hora não fornecida:', { dateStr, timeStr });
            return null;
        }
        
        // Extrair dia, mês e ano da data
        let day, month, year;
        
        if (dateStr.includes('/')) {
            // Formato DD/MM/YYYY
            [day, month, year] = dateStr.split('/');
        } else if (dateStr.includes('-')) {
            // Formato YYYY-MM-DD
            [year, month, day] = dateStr.split('-');
        } else {
            console.error('Formato de data não suportado:', dateStr);
            return null;
        }
        
        // Garantir que o tempo tenha minutos
        let hours, minutes;
        if (timeStr.includes(':')) {
            [hours, minutes] = timeStr.split(':');
        } else {
            hours = timeStr;
            minutes = '00';
        }
        
        // Criar string no formato YYYY-MM-DDTHH:MM:SS
        const pad = num => num.toString().padStart(2, '0');
        const date = new Date(
            parseInt(year, 10),
            parseInt(month, 10) - 1,
            parseInt(day, 10),
            parseInt(hours, 10),
            parseInt(minutes, 10),
            0
        );
        
        if (isNaN(date.getTime())) {
            console.error('Data/hora inválida:', { dateStr, timeStr });
            return null;
        }
        
        // Formatar para ISO 8601 sem timezone (o servidor vai tratar o timezone)
        return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}` +
               `T${pad(date.getHours())}:${pad(date.getMinutes())}:00`;
    } catch (error) {
        console.error('Erro ao formatar data/hora:', error);
        return null;
    }
}

// Função para calcular o horário de término
function calculateEndTime(startTime, durationMinutes) {
    try {
        let startDate;
        
        if (typeof startTime === 'string') {
            // Se for uma string, assumir que está no formato YYYY-MM-DDTHH:MM:SS
            startDate = new Date(startTime);
        } else if (startTime instanceof Date) {
            startDate = new Date(startTime);
        } else {
            console.error('Formato de data de início inválido:', startTime);
            return null;
        }

        if (isNaN(startDate.getTime())) {
            console.error('Hora de início inválida:', startTime);
            return null;
        }
        
        // Adicionar a duração
        const endDate = new Date(startDate.getTime() + (durationMinutes * 60 * 1000));
        
        // Retornar no mesmo formato que formatDateTime
        const pad = num => num.toString().padStart(2, '0');
        return `${endDate.getFullYear()}-${pad(endDate.getMonth() + 1)}-${pad(endDate.getDate())}` +
               `T${pad(endDate.getHours())}:${pad(endDate.getMinutes())}:00`;
    } catch (error) {
        console.error('Erro ao calcular horário de término:', error);
        return null;
    }
}

// Função para salvar ou atualizar um agendamento
        // Função para salvar ou atualizar um agendamento
        // Função para salvar ou atualizar um agendamento
async function submitAgendamentoForm(form, isEdit = false) {
    const btnSalvar = document.getElementById('btnSalvar');
    const spinner = document.getElementById('loadingSpinner');
    const btnText = document.getElementById('btnText');
    
    try {
        // Mostrar loading
        btnSalvar.disabled = true;
        spinner.classList.remove('d-none');
        btnText.textContent = 'Salvando...';
        
        const formData = new FormData(form);
        
        // Obter valores do formulário (fallback para valor diretamente do DOM se o FormData estiver vazio)
        let agendamentoId = formData.get('agendamentoId');
        if (!agendamentoId) {
            const idEl = document.getElementById('agendamentoId');
            if (idEl) agendamentoId = idEl.value || '';
        }
        const clienteId = parseInt(formData.get('clienteId'));
        const procedimentoId = parseInt(formData.get('procedimentoId'));
        const profissionalIdStr = formData.get('profissionalId');
        const profissionalId = profissionalIdStr && profissionalIdStr !== 'null' && profissionalIdStr !== 'undefined' ? parseInt(profissionalIdStr) : null;
        const valorCobrado = parseFloat(formData.get('valorCobrado') || '0');
        const dataInicio = formData.get('data');
        const horaInicio = formData.get('horaInicio');
        const duracao = parseInt(formData.get('duracao') || '30');
        const observacoes = formData.get('observacoes');

        // Registrar qual opção de procedimento está selecionada (id e texto)
        try {
            const procSelect = document.getElementById('procedimentoId');
            if (procSelect) {
                const selectedOpt = procSelect.options[procSelect.selectedIndex];
                console.log('Procedimento selecionado no select:', { value: selectedOpt ? selectedOpt.value : null, text: selectedOpt ? selectedOpt.text : null, dataset: selectedOpt ? selectedOpt.dataset : null });
            } else {
                console.warn('Elemento select#procedimentoId não encontrado no DOM ao submeter o formulário');
            }
        } catch (e) {
            console.warn('Erro ao registrar procedimento selecionado:', e);
        }
        
        // Validar campos obrigatórios
        if (!clienteId || !procedimentoId || !dataInicio || !horaInicio || !duracao) {
            throw new Error('Preencha todos os campos obrigatórios');
        }
        
        // Usar a data e hora exatamente como foram informadas, sem conversão
        // Formatar a data para o padrão YYYY-MM-DD
        const dataFormatada = dataInicio; // Já está no formato YYYY-MM-DD
        const horaFormatada = horaInicio; // Já está no formato HH:mm
        
        // Criar objeto com os dados formatados
        const start = {
            date: dataFormatada,
            time: horaFormatada,
            // Criar um timestamp local para cálculos internos
            timestamp: new Date(`${dataFormatada}T${horaFormatada}:00`).getTime()
        };
        
        // Calcular horário de término baseado na duração
        const endTimestamp = start.timestamp + (duracao * 60000);
        const endDate = new Date(endTimestamp);
        const end = {
            date: endDate.toISOString().split('T')[0], // Formato YYYY-MM-DD
            time: `${String(endDate.getHours()).padStart(2, '0')}:${String(endDate.getMinutes()).padStart(2, '0')}`,
            timestamp: endTimestamp
        };
        
        // Criar datas ISO para a API (usando o fuso horário local sem conversão)
        const startISO = new Date(start.timestamp).toISOString();
        const endISO = new Date(end.timestamp).toISOString();
        
        console.log('Dados do agendamento:', {
            clienteId,
            procedimentoId,
            profissionalId,
            valorCobrado,
            data: start.date,
            horaInicio: start.time,
            startTime: startISO,
            endTime: endISO,
            observacoes
        });

        // Verificar disponibilidade
        console.log('Verificando disponibilidade...');
        const disponivel = await verificarDisponibilidade(
            profissionalId,
            startISO,
            endISO,
            agendamentoId ? parseInt(agendamentoId) : null
        );
        
        if (!disponivel) {
            throw new Error('Já existe um agendamento neste horário');
        }
        
        // Preparar dados para envio
        // Obter o nome do procedimento selecionado para maior clareza no backend
        let procedimentoNome = null;
        try {
            const procSelect = document.getElementById('procedimentoId');
            const selectedOpt = procSelect ? procSelect.options[procSelect.selectedIndex] : null;
            if (selectedOpt) procedimentoNome = selectedOpt.text;
        } catch (e) {
            console.warn('Não foi possível obter o nome do procedimento selecionado:', e);
        }

        const data = {
            clienteId,
            procedimentoId,
            profissionalId,
            valorCobrado,
            // Usar as datas formatadas corretamente
            data: start.date,
            horaInicio: start.time,
            startTime: startISO,
            endTime: endISO,
            observacoes: observacoes || null,
            status: 'AGENDADO',
            procedimentoNome,
            // Incluir timestamp para referência
            timestamp: start.timestamp,
            // Incluir data e hora de término formatadas
            dataFim: end.date,
            horaFim: end.time
        };

        console.log('Enviando dados para a API:', data);
        
        // Determinar a URL e o método HTTP
        const url = isEdit && agendamentoId 
            ? `/api/agendamentos/${agendamentoId}`
            : '/api/agendamentos';
            
    // Usar PATCH para edição parcial (mais seguro) e POST para criação
    const method = isEdit ? 'PATCH' : 'POST';
        
        // Fazer a requisição para a API
        const response = await fetch(url, {
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
            },
            body: JSON.stringify(data)
        });
        
        // Tentar ler JSON; se o servidor retornar HTML (404/500), lançar erro informativo
        let responseData = null;
        const text = await response.text();
        try {
            responseData = text ? JSON.parse(text) : null;
        } catch (e) {
            console.error('Resposta não-JSON da API ao criar/atualizar agendamento:', text);
            throw new Error(`Resposta inválida do servidor: ${response.status} ${response.statusText}`);
        }

        if (!response.ok) {
            console.error('Resposta de erro da API ao criar/agendar:', response.status, responseData);
            // Mostrar toast com a mensagem retornada pelo servidor, se houver
            showToast(responseData.error || responseData.message || 'Erro ao salvar agendamento. Verifique os logs do servidor.', true);
            throw new Error(responseData.error || responseData.message || 'Erro ao salvar agendamento');
        }

        console.log('Resposta da API:', responseData);
        
        // Recarregar os agendamentos
        await loadAppointmentsForDate(currentDate);
        
        // Fechar o modal de forma robusta
        (function closeAgendamentoModal() {
            try {
                const modalEl = document.getElementById('agendamentoModal');
                if (!modalEl) return;

                // Garante que existe uma instância do modal (cria se necessário)
                const modalInstance = bootstrap.Modal.getOrCreateInstance(modalEl);
                modalInstance.hide();

                // Remover manualmente qualquer backdrop residual
                const backdrop = document.querySelector('.modal-backdrop');
                if (backdrop && backdrop.parentNode) {
                    backdrop.parentNode.removeChild(backdrop);
                }

                // Garantir que a classe modal-open foi removida do body
                document.body.classList.remove('modal-open');

                // Resetar o formulário para estado limpo
                try {
                    form.reset();
                    document.getElementById('agendamentoId').value = '';
                } catch (e) {
                    console.warn('Falha ao resetar o formulário do agendamento:', e);
                }
            } catch (e) {
                console.error('Erro ao tentar fechar o modal de agendamento:', e);
            }
        })();
        
        // Mostrar mensagem de sucesso
        showToast(`Agendamento ${isEdit ? 'atualizado' : 'criado'} com sucesso!`, false);
        
    } catch (error) {
        console.error('Erro ao salvar agendamento:', error);
        
        // Verifica se o erro é relacionado a data no passado
        if (error.message && error.message.includes('já passou')) {
            showErrorModal(error.message);
        } else {
            showErrorModal(error.message || 'Ocorreu um erro ao salvar o agendamento. Por favor, verifique os dados e tente novamente.');
        }
    } finally {
        // Restaurar o botão
        btnSalvar.disabled = false;
        spinner.classList.add('d-none');
        btnText.textContent = 'Salvar';
    }
}

        function formatDateForAPI(dateString) {
            if (!dateString) return null;
            const date = new Date(dateString);
            // Ajusta para o fuso horário local e formata como YYYY-MM-DDTHH:MM:SS
            const pad = num => num.toString().padStart(2, '0');
            const tzOffset = -date.getTimezoneOffset();
            const tzSign = tzOffset >= 0 ? '+' : '-';
            const tzHours = Math.floor(Math.abs(tzOffset) / 60);
            const tzMinutes = Math.abs(tzOffset) % 60;
            
            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T` +
                   `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}` +
                   `${tzSign}${pad(tzHours)}:${pad(tzMinutes)}`;
        }

        // Função temporária para verificação de disponibilidade
        // Retorna true para permitir todos os agendamentos
        async function verificarDisponibilidade(profissionalId, startTime, endTime, agendamentoId = null) {
            console.log('Verificação de disponibilidade temporariamente desativada - Permitindo todos os agendamentos');
            return true;
        }
        
        // Função original comentada
        /*
        async function verificarDisponibilidade(profissionalId, startTime, endTime, agendamentoId = null) {
            try {
                console.log('Verificando disponibilidade para:', {
                    profissionalId,
                    startTime,
                    endTime,
                    agendamentoId: agendamentoId || 'Novo agendamento'
                });

                if (!profissionalId) {
                    console.log('Nenhum profissional selecionado, considerando horário disponível');
                    return true;
                }

                const url = `/api/agendamentos/verificar-disponibilidade?` +
                           `profissionalId=${profissionalId}&` +
                           `dataInicio=${encodeURIComponent(startTime)}&` +
                           `dataFim=${encodeURIComponent(endTime)}`;

                console.log('Enviando parâmetros de disponibilidade:', url);

                const response = await fetchWithAuth(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response) {
                    console.error('Resposta inválida ao verificar disponibilidade');
                    return false;
                }

                const result = await response.json();
                
                if (response.status === 200 && result.success === true) {
                    console.log('Disponibilidade verificada:', result.disponivel);
                    return result.disponivel === true;
                }
                
                console.error('Erro ao verificar disponibilidade:', result?.error || 'Erro desconhecido');
                return false;
                
            } catch (error) {
                console.error('Erro na verificação de disponibilidade:', error);
                return false;
            }
        }
        */
        
        // Função para carregar agendamentos
        async function loadAppointmentsForDate(date) {
            try {
                // Exibir spinner
                const loadingEl = document.getElementById('appointmentsLoading');
                const emptyEl = document.getElementById('appointmentsEmpty');
                const containerEl = document.getElementById('appointmentsContainer');
                
                if (loadingEl) loadingEl.classList.remove('d-none');
                if (emptyEl) emptyEl.classList.add('d-none');
                if (containerEl) containerEl.classList.add('d-none');
                
                // Formatar data para YYYY-MM-DD
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const dateStr = `${year}-${month}-${day}`;
                
                // Buscar agendamentos para a data
                const response = await fetchWithAuth(`/api/agendamentos?data=${dateStr}`);
                
                if (!response) {
                    updateAppointmentsList([]);
                    return [];
                }
                
                const body = await response.json();
                console.log('Resposta da API de agendamentos:', body);
                
                // Processar resposta da API
                let agendamentos = [];
                if (Array.isArray(body)) {
                    agendamentos = body;
                } else if (body && Array.isArray(body.data)) {
                    agendamentos = body.data;
                }
                
                console.log('Agendamentos processados:', agendamentos);
                
                // Mapear para o formato esperado
                const mapped = agendamentos.map(ag => {
                    if (!ag.data || !ag.horaInicio) {
                        console.log('Agendamento sem data ou hora:', ag);
                        return null;
                    }
                    
                    try {
                        // Obter data e hora diretamente do banco de dados
                        const [y, m, d] = ag.data.split('-').map(Number);
                        const [hh, mm] = ag.horaInicio.split(':');
                        
                        // Criar a data local diretamente sem ajustes de fuso horário
                        const localDate = new Date(y, m - 1, d, hh, mm || 0, 0, 0);
                        
                        // Debug: Verificar estrutura do objeto ag
                        console.log('Processando agendamento - Estrutura completa:', ag);
                        console.log('Chaves disponíveis no objeto agendamento:', Object.keys(ag));
                        
                        // Verificar se há um objeto profissional aninhado
                        if (ag.profissional) {
                            console.log('Objeto profissional encontrado:', ag.profissional);
                            console.log('Tipo do objeto profissional:', typeof ag.profissional);
                            console.log('Chaves do objeto profissional:', Object.keys(ag.profissional));
                        }
                        
                        // Verificar se há um ID de profissional direto no objeto
                        const possibleIds = ['profissionalId', 'profissional_id', 'professionalId', 'professional_id'];
                        const foundId = possibleIds.find(id => ag[id] !== undefined);
                        console.log('ID de profissional encontrado:', foundId ? `${foundId}: ${ag[foundId]}` : 'Nenhum ID encontrado');
                        
                        // Extrair informações do cliente
                        const clienteNome = ag.cliente?.nome || ag.cliente?.name || 'Cliente não informado';
                        
                        // Extrair informações do procedimento
                        const procedimentoNome = ag.procedimento?.name || ag.procedimento?.nome || 'Procedimento não informado';
                        const duracao = ag.duracao || ag.procedimento?.duracao || 30;
                        
                        // Extrair informações do profissional
                        let profissionalId = ag.profissionalId || ag.profissional_id || ag.professionalId || ag.professional_id || null;
                        let profissionalNome = 'Não informado';
                        
                        // Primeiro tenta pegar do objeto profissional aninhado
                        if (ag.profissional) {
                            profissionalId = ag.profissional.id || ag.profissional._id || profissionalId;
                            profissionalNome = ag.profissional.nome || ag.profissional.name || 
                                             ag.profissionalNome || ag.nomeProfissional || 'Não informado';
                        }
                        
                        // Se ainda não encontrou, tenta buscar pelo ID no mapa de profissionais
                        if (profissionalId && (!profissionalNome || profissionalNome === 'Não informado')) {
                            const nome = getProfessionalNameById(profissionalId);
                            if (nome) profissionalNome = nome;
                        }
                        
                        console.log(`Agendamento ${ag.id}:`, {
                            cliente: clienteNome,
                            procedimento: procedimentoNome,
                            data: ag.data,
                            hora: ag.horaInicio,
                            status: ag.status
                        });
                        
                        return {
                            id: ag.id,
                            cliente: clienteNome,
                            profissional: profissionalNome,
                            profissionalId: profissionalId,
                            procedimento: procedimentoNome,
                            dataHora: localDate,
                            status: (ag.status || 'AGENDADO').toUpperCase(),
                            duracao: duracao,
                            valorCobrado: ag.valorCobrado || 0,
                            observacoes: ag.observacoes || ''
                        };
                    } catch (e) {
                        return null;
                    }
                }).filter(Boolean);
                
                // Atualizar a UI
                updateAppointmentsList(mapped);
                updateAppointmentsTable(mapped);
                
                return mapped;
                
            } catch (error) {
                showToast('Erro ao carregar agendamentos', true);
                updateAppointmentsList([]);
                return [];
            } finally {
                // Garantir que o loading seja escondido
                const loadingEl = document.getElementById('appointmentsLoading');
                if (loadingEl) loadingEl.classList.add('d-none');
            }
        }

        // Verificar autenticação ao carregar a página
        function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = '/login';
                return false;
            }
            return true;
        }

        // Função para verificar e atualizar status dos agendamentos
        async function verificarEAtualizarStatus() {
            try {
                console.log('Iniciando verificação de status dos agendamentos...');
                const agora = new Date();
                
                // Formatar data para YYYY-MM-DD (mesmo formato usado em loadAppointmentsForDate)
                const year = agora.getFullYear();
                const month = String(agora.getMonth() + 1).padStart(2, '0');
                const day = String(agora.getDate()).padStart(2, '0');
                const dateStr = `${year}-${month}-${day}`;
                
                console.log('Buscando agendamentos para a data:', dateStr);
                const response = await fetchWithAuth(`/api/agendamentos?data=${dateStr}`);
                
                if (!response || !response.ok) {
                    console.error('Erro ao buscar agendamentos:', response?.statusText);
                    return;
                }
                
                const body = await response.json();
                console.log('Resposta da API de agendamentos:', body);
                
                // Processar resposta da API da mesma forma que em loadAppointmentsForDate
                let agendamentos = [];
                if (Array.isArray(body)) {
                    agendamentos = body;
                } else if (body && Array.isArray(body.data)) {
                    agendamentos = body.data;
                }
                
                console.log(`${agendamentos.length} agendamentos encontrados para verificação`);
                
                // Mapear para o formato esperado
                const agendamentosMapeados = agendamentos.map(ag => {
                    if (!ag.data || !ag.horaInicio) {
                        console.log('Agendamento sem data ou hora:', ag);
                        return null;
                    }
                    
                    try {
                        // Obter data e hora diretamente do banco de dados
                        const [y, m, d] = ag.data.split('-').map(Number);
                        const [hh, mm] = ag.horaInicio.split(':');
                        
                        // Criar a data local diretamente sem ajustes de fuso horário
                        const dataHoraAgendamento = new Date(y, m - 1, d, hh, mm || 0, 0, 0);
                        
                        // Calcular horário de término (início + duração em minutos)
                        const duracaoMinutos = ag.duracao || 30; // Default 30 minutos se não informado
                        const dataHoraTermino = new Date(dataHoraAgendamento.getTime() + (duracaoMinutos * 60000));
                        
                        // Extrair informações do profissional
                        let profissionalId = ag.profissionalId || ag.profissional_id || ag.profissional?.id || ag.profissional?._id || null;
                        
                        return {
                            id: ag.id,
                            data: ag.data,
                            horaInicio: ag.horaInicio,
                            duracao: duracaoMinutos,
                            status: (ag.status || 'AGENDADO').toUpperCase(),
                            dataHora: dataHoraAgendamento,
                            dataHoraTermino: dataHoraTermino,
                            profissionalId: profissionalId,
                            clienteId: ag.clienteId || ag.cliente_id || ag.cliente?.id || ag.cliente?._id || null,
                            procedimentoId: ag.procedimentoId || ag.procedimento_id || ag.procedimento?.id || ag.procedimento?._id || null
                        };
                    } catch (e) {
                        console.error('Erro ao processar agendamento:', ag, e);
                        return null;
                    }
                }).filter(Boolean);
                
                console.log(`${agendamentosMapeados.length} agendamentos processados`);
                
                // 1. Verificar agendamentos que devem iniciar (AGENDADO -> EM_ANDAMENTO)
                const agendamentosParaIniciar = agendamentosMapeados.filter(ag => {
                    // Pular agendamentos já finalizados ou cancelados
                    if (ag.status !== 'AGENDADO') {
                        return false;
                    }
                    
                    // Verificar se o horário do agendamento já passou
                    return agora >= ag.dataHora && agora < ag.dataHoraTermino;
                });
                
                console.log(`${agendamentosParaIniciar.length} agendamentos para iniciar`);
                
                // 2. Verificar agendamentos que devem ser finalizados (EM_ANDAMENTO -> FINALIZADO)
                const agendamentosParaFinalizar = agendamentosMapeados.filter(ag => {
                    // Pular agendamentos que não estão em andamento
                    if (ag.status !== 'EM_ANDAMENTO') {
                        return false;
                    }
                    
                    // Verificar se o horário de término já passou
                    return agora >= ag.dataHoraTermino;
                });
                
                console.log(`${agendamentosParaFinalizar.length} agendamentos para finalizar`);
                
                // Função auxiliar para atualizar o status de um agendamento
                async function atualizarStatusAgendamento(agendamento, novoStatus) {
                    try {
                        console.log(`Atualizando agendamento ${agendamento.id} para ${novoStatus}...`);
                        
                        // Preparar os dados para atualização
                        const updateData = {
                            status: novoStatus,
                            data: agendamento.data,
                            horaInicio: agendamento.horaInicio
                        };
                        
                        // Incluir apenas os campos que existem no objeto
                        if (agendamento.profissionalId) updateData.profissionalId = agendamento.profissionalId;
                        if (agendamento.clienteId) updateData.clienteId = agendamento.clienteId;
                        if (agendamento.procedimentoId) updateData.procedimentoId = agendamento.procedimentoId;
                        
                        const response = await fetchWithAuth(`/api/agendamentos/${agendamento.id}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(updateData)
                        });
                        
                        if (!response.ok) {
                            const error = await response.text();
                            throw new Error(`HTTP ${response.status}: ${error}`);
                        }
                        
                        const result = await response.json();
                        console.log('Resposta da API:', result);
                        
                        // Atualizar a interface do usuário
                        if (result && result.success) {
                            // Atualizar o item na lista
                            const itemElement = document.querySelector(`[data-id="${agendamento.id}"]`);
                            if (itemElement) {
                                const statusElement = itemElement.querySelector('.badge');
                                if (statusElement) {
                                    if (novoStatus === 'EM_ANDAMENTO') {
                                        statusElement.className = 'badge bg-warning text-dark';
                                        statusElement.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>EM ANDAMENTO';
                                    } else if (novoStatus === 'FINALIZADO') {
                                        statusElement.className = 'badge bg-success text-white';
                                        statusElement.innerHTML = '<i class="bi bi-check-circle me-1"></i>FINALIZADO';
                                    }
                                    itemElement.setAttribute('data-status', novoStatus);
                                }
                            }
                            
                            // Atualizar o calendário
                            const calendarDay = document.querySelector(`[data-date="${agendamento.data}"]`);
                            if (calendarDay) {
                                calendarDay.classList.add('has-appointments');
                            }
                            
                            console.log(`Agendamento ${agendamento.id} atualizado para ${novoStatus}`);
                            return true;
                        }
                        
                        return false;
                        
                    } catch (error) {
                        console.error(`Erro ao atualizar agendamento ${agendamento.id} para ${novoStatus}:`, error);
                        return false;
                    }
                }
                
                // 3. Processar agendamentos para iniciar
                for (const ag of agendamentosParaIniciar) {
                    await atualizarStatusAgendamento(ag, 'EM_ANDAMENTO');
                }
                
                // 4. Processar agendamentos para finalizar
                for (const ag of agendamentosParaFinalizar) {
                    await atualizarStatusAgendamento(ag, 'FINALIZADO');
                }
                
            } catch (error) {
                console.error('Erro na verificação de status dos agendamentos:', error);
            }
        }

        // Inicialização da página
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Página carregada, inicializando...');
            
            if (!checkAuth()) {
                console.log('Usuário não autenticado, redirecionando...');
                return;
            }
            
            console.log('Inicializando tooltips...');
            // Inicializar tooltips
            var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl, {
                    trigger: 'hover',
                    delay: {show: 300, hide: 100}
                });
            });
            
            // Inicializar a barra lateral
            if (window.initSidebar) {
                console.log('Inicializando barra lateral...');
                window.initSidebar();
            }
            
            console.log('Configurando eventos...');
            // Configurar eventos
            setupEventListeners();
            
            // Carregar dados iniciais
            console.log('Carregando dados iniciais...');
            loadInitialData().then(() => {
                console.log('Dados iniciais carregados com sucesso');
                
                // Inicializar o calendário após carregar os dados
                console.log('Renderizando calendário...');
                renderCalendar();
                
                // Configurar o formulário
                console.log('Configurando formulário...');
                const form = document.getElementById('agendamentoForm');
                if (form) {
                    form.addEventListener('submit', async (e) => {
                        e.preventDefault();
                        const isEdit = !!document.getElementById('agendamentoId').value;
                        await submitAgendamentoForm(form, isEdit);
                    });
                }
                
                // Verificar status dos agendamentos a cada minuto
                console.log('Configurando verificação periódica de status...');
                setInterval(verificarEAtualizarStatus, 60000); // 60 segundos
                
                // Verificar imediatamente após um curto atraso
                console.log('Agendando verificação inicial de status...');
                setTimeout(() => {
                    console.log('Executando verificação inicial de status...');
                    verificarEAtualizarStatus().catch(error => {
                        console.error('Erro na verificação inicial de status:', error);
                    });
                }, 3000); // Aguarda 3 segundos para garantir que tudo esteja carregado
                
            }).catch(error => {
                console.error('Erro ao carregar dados iniciais:', error);
            });
        });
    </script>
</body>
</html>
