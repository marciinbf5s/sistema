<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agenda - Sistema de Agendamento</title>
    
    <!-- CSS Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    
    <!-- Custom CSS -->
    <link href="css/sidebar.css" rel="stylesheet">
    <link href="css/theme.css" rel="stylesheet">
    
    <style>
        :root {
            --primary: #f0b354;    /* Dourado */
            --primary-hover: #d9a24a;   /* Dourado mais escuro */
            --secondary: #041a31; /* Azul Royal */
            --secondary-hover: #031425; /* Azul Royal mais escuro */
            --light: #f8f9fa;
            --dark: #212529;
            --background-light: #f6f8f8;
            --border-color: rgba(4, 26, 49, 0.1);
        }
        
        body {
            background-color: var(--background-light);
            font-family: 'Inter', sans-serif;
            color: var(--dark);
            overflow-x: hidden;
        }
        
        /* Estilos do Calendário */
        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            text-align: center;
            font-weight: 500;
            color: #6c757d;
            margin-bottom: 0.5rem;
        }
        
        .calendar-days {
            display: grid;
            grid-template-columns: repeat(7, minmax(0, 1fr));
            gap: 0.25rem;
            width: 100%;
            margin: 0 auto;
        }
        
        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            width: 100%;
            max-width: 2.5rem;
            height: auto;
            margin: 0 auto;
            font-size: 0.9rem;
        }
        
        .calendar-day:hover {
            background-color: rgba(240, 179, 84, 0.1);
        }
        
        .calendar-day.active {
            background-color: var(--primary);
            color: white;
            font-weight: 600;
        }
        
        .calendar-day.today {
            background-color: rgba(240, 179, 84, 0.4);
            font-weight: 600;
            color: #212529;
        }
        
        .calendar-day.text-muted {
            color: #adb5bd !important;
        }
        
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .status-pendente {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .status-confirmado {
            background-color: #d4edda;
            color: #155724;
        }
        
        .status-cancelado {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .status-finalizado {
            background-color: #e2e3e5;
            color: #383d41;
        }
        
        @media (max-width: 1199.98px) {
            .main-content {
                margin-left: 0;
                width: 100%;
            }
        }
        
        @media (max-width: 768px) {
            .calendar-day {
                max-width: 2rem;
                font-size: 0.8rem;
            }
        }
        
        @media (max-width: 576px) {
            .calendar-day {
                max-width: 1.8rem;
                font-size: 0.75rem;
            }
        }

        /* Legenda de status abaixo do calendário */
        .legend-status {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
            align-items: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--dark);
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.06);
            box-shadow: 0 0 0 2px rgba(255,255,255,0.6) inset;
        }

        /* Cores claras para os status */
        .legend-agendado { background: #cfe8ff; }      /* azul claro */
        .legend-andamento { background: #fff6d6; }    /* amarelo claro */
        .legend-finalizado { background: #d8f6dc; }   /* verde claro */
        .legend-cancelado { background: #f8d7da; }    /* vermelho claro */

        /* Backgrounds para itens de agendamento por status */
        .list-group-item.status-AGENDADO { background-color: #cfe8ff; }
        .list-group-item.status-EM_ANDAMENTO { background-color: #fff6d6; }
        .list-group-item.status-FINALIZADO { background-color: #d8f6dc; }
        .list-group-item.status-CANCELADO { background-color: #f8d7da; }

        /* Pequena borda e contraste para melhor leitura */
        .list-group-item.status-AGENDADO,
        .list-group-item.status-EM_ANDAMENTO,
        .list-group-item.status-FINALIZADO,
        .list-group-item.status-CANCELADO {
            border: 1px solid rgba(0,0,0,0.04);
        }

        /* Aumentar separação entre itens e adicionar traço mais escuro */
        .list-group-item.status-AGENDADO,
        .list-group-item.status-EM_ANDAMENTO,
        .list-group-item.status-FINALIZADO,
        .list-group-item.status-CANCELADO {
            padding: 0.75rem 1rem;
            margin-bottom: 0.45rem;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(16,24,40,0.03);
            position: relative;
            overflow: visible;
            border: 1px solid rgba(0,0,0,0.12); /* borda geral mais forte */
            transition: transform 0.12s ease, box-shadow 0.12s ease, border-left-color 0.12s ease;
        }

        /* borda esquerda colorida por status para destacar */
        .list-group-item.status-AGENDADO { border-left: 4px solid rgba(67,97,238,0.95); }
        .list-group-item.status-EM_ANDAMENTO { border-left: 4px solid rgba(255,193,7,0.95); }
        .list-group-item.status-FINALIZADO { border-left: 4px solid rgba(75,181,67,0.95); }
        .list-group-item.status-CANCELADO { border-left: 4px solid rgba(220,53,69,0.95); }

        /* separador consistente: borda-top para itens seguintes (evita traço 'solto') */
        .list-group-item.status-AGENDADO + .list-group-item.status-AGENDADO,
        .list-group-item.status-EM_ANDAMENTO + .list-group-item.status-EM_ANDAMENTO,
        .list-group-item.status-FINALIZADO + .list-group-item.status-FINALIZADO,
        .list-group-item.status-CANCELADO + .list-group-item.status-CANCELADO,
        /* também aplicar quando status diferentes entre itens */
        .list-group-item + .list-group-item {
            border-top: 1px solid rgba(0,0,0,0.10);
            margin-top: 0.4rem; /* espaço antes do traço */
            padding-top: 0.4rem; /* espaço interno após o traço */
        }

        .list-group-item.status-AGENDADO:last-child,
        .list-group-item.status-EM_ANDAMENTO:last-child,
        .list-group-item.status-FINALIZADO:last-child,
        .list-group-item.status-CANCELADO:last-child {
            margin-bottom: 0;
        }

        /* Aplicar o mesmo tom de cinza e estilo de texto da tabela de clientes na aba 'Lista' */
        /* Usamos selectors com escopo para evitar interferir em outras tabelas */
        #list-tab-pane .table {
            --bs-table-striped-bg: #f8f9fa; /* tom de cinza usado na tabela de clientes */
            --bs-table-hover-bg: #f1f3f5;
            background-color: transparent;
        }

        /* Aplicar background aos rows e hover similar à tabela clientes */
        #list-tab-pane .table tbody tr {
            background-color: var(--bs-table-striped-bg);
        }

        #list-tab-pane .table tbody tr:hover {
            background-color: var(--bs-table-hover-bg);
        }

        /* Texto preto e negrito nas células */
        #list-tab-pane .table tbody tr td {
            color: #000 !important;
            font-weight: 600 !important;
        }

        /* Cabeçalho da tabela (linha de títulos) com fundo cinza levemente mais escuro */
        #list-tab-pane .table thead th {
            background-color: #e9ecef !important; /* cinza um pouco mais escuro */
            color: #212529 !important; /* texto escuro */
            font-weight: 700 !important;
            border-bottom: 1px solid #e9ecef !important;
        }
    </style>
</head>
<body>
    <div class="d-flex">
        <!-- Menu lateral -->
        <div id="sidebar"></div>
        
        <!-- Conteúdo principal -->
        <div class="main-content flex-grow-1">
            <div class="container-fluid p-0">
                <!-- Botão para mobile -->
                <button class="btn btn-primary d-lg-none mb-3" id="sidebarToggle">
                    <i class="bi bi-list"></i> Menu
                </button>
                
                <!-- Cabeçalho (estilo igual à página Clientes) -->
                <div class="page-header mb-4">
                    <div class="row align-items-center mb-3">
                        <div class="col-12 col-md-6 mb-3 mb-md-0">
                            <div>
                                <h1 class="page-title fw-bolder" style="font-weight: 800 !important; margin-bottom: 10px;">
                                    <i class="bi bi-calendar-event-fill me-2" style="color: #f0b354;"></i>Agenda
                                </h1>
                                <p class="text-muted mb-0 mt-2">Gerencie os agendamentos do seu negócio</p>
                            </div>
                        </div>
                        <div class="col-12 col-md-6">
                            <div class="d-flex flex-wrap justify-content-md-end" style="gap: 10px;">
                                <button class="btn btn-primary d-flex align-items-center" id="newAgendamentoBtn" style="height: 38px;">
                                    <i class="bi bi-plus-lg me-1"></i>
                                    <span class="d-none d-sm-inline">Novo Agendamento</span>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="border-bottom mt-3"></div>
                </div>
                
                <!-- Abas de Navegação -->
                <ul class="nav nav-tabs mb-4" id="mainTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="calendar-tab" data-bs-toggle="tab" 
                                data-bs-target="#calendar-tab-pane" type="button" role="tab" 
                                aria-controls="calendar-tab-pane" aria-selected="true">
                            <i class="bi bi-calendar3 me-2"></i>Calendário
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="list-tab" data-bs-toggle="tab" 
                                data-bs-target="#list-tab-pane" type="button" role="tab" 
                                aria-controls="list-tab-pane" aria-selected="false">
                            <i class="bi bi-list-ul me-2"></i>Lista
                        </button>
                    </li>
                </ul>
                
                <!-- Conteúdo das Abas -->
                <div class="tab-content" id="mainTabsContent">
                    <!-- Aba do Calendário -->
                    <div class="tab-pane fade show active" id="calendar-tab-pane" role="tabpanel" aria-labelledby="calendar-tab" tabindex="0">
                        <div class="row g-4">
                            <!-- Calendário -->
                            <div class="col-lg-4">
                                <div class="card">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center mb-3">
                                            <h5 class="card-title mb-0">Calendário</h5>
                                            <div class="btn-group">
                                                <button class="btn btn-sm btn-outline-secondary" id="prevMonth">
                                                    <i class="bi bi-chevron-left"></i>
                                                </button>
                                                <button class="btn btn-sm btn-outline-secondary position-relative" id="currentMonth">
                                                    <span id="currentMonthText">Outubro 2023</span>
                                                </button>
                                                <!-- Seletor de mês/ano (inicialmente escondido) -->
                                                <div id="monthPicker" class="card p-2 position-absolute d-none" style="z-index:1050; min-width:200px; top:40px; left:0">
                                                    <div class="d-flex gap-2 align-items-center mb-2">
                                                        <select id="monthSelect" class="form-select form-select-sm">
                                                            <option value="0">Janeiro</option>
                                                            <option value="1">Fevereiro</option>
                                                            <option value="2">Março</option>
                                                            <option value="3">Abril</option>
                                                            <option value="4">Maio</option>
                                                            <option value="5">Junho</option>
                                                            <option value="6">Julho</option>
                                                            <option value="7">Agosto</option>
                                                            <option value="8">Setembro</option>
                                                            <option value="9">Outubro</option>
                                                            <option value="10">Novembro</option>
                                                            <option value="11">Dezembro</option>
                                                        </select>
                                                        <input id="yearInput" class="form-control form-control-sm" type="number" style="width:90px" />
                                                    </div>
                                                    <div class="d-flex justify-content-end gap-2">
                                                        <button id="monthPickerCancel" class="btn btn-sm btn-secondary">Cancelar</button>
                                                        <button id="monthPickerGo" class="btn btn-sm btn-primary">Ir</button>
                                                    </div>
                                                </div>
                                                <button class="btn btn-sm btn-outline-secondary" id="nextMonth">
                                                    <i class="bi bi-chevron-right"></i>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="calendar-container">
                                            <div class="calendar-weekdays">
                                                <div>Dom</div>
                                                <div>Seg</div>
                                                <div>Ter</div>
                                                <div>Qua</div>
                                                <div>Qui</div>
                                                <div>Sex</div>
                                                <div>Sáb</div>
                                            </div>
                                            <div class="calendar-days" id="calendarDays">
                                                <!-- Dias serão preenchidos via JavaScript -->
                                            </div>
                                            <!-- Legenda de status -->
                                            <div class="legend-status" aria-hidden="false">
                                                <div class="legend-item"><span class="legend-color legend-agendado" aria-hidden="true"></span> Agendado</div>
                                                <div class="legend-item"><span class="legend-color legend-andamento" aria-hidden="true"></span> Em andamento</div>
                                                <div class="legend-item"><span class="legend-color legend-finalizado" aria-hidden="true"></span> Finalizado</div>
                                                <div class="legend-item"><span class="legend-color legend-cancelado" aria-hidden="true"></span> Cancelado</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Lista de Agendamentos -->
                            <div class="col-lg-8">
                                <div class="card">
                                    <div class="card-body">
                                        <h5 class="card-title mb-2">Agendamentos para <span id="selectedDate">hoje</span></h5>
                                        <!-- Separador visual destacado -->
                                        <div class="appointments-separator-wrapper mb-3">
                                            <hr class="appointments-separator" />
                                        </div>
                                        
                                        <div id="appointmentsList">
                                            <!-- Controles de estado: spinner, mensagem vazia e lista -->
                                            <div id="appointmentsLoading" class="text-center py-5 d-none" aria-live="polite">
                                                <div class="spinner-border text-primary" role="status" aria-hidden="true"></div>
                                                <div class="mt-2 text-muted">Carregando agendamentos...</div>
                                            </div>

                                            <div id="appointmentsEmpty" class="text-center text-muted py-5 d-none" aria-live="polite">
                                                <i class="bi bi-calendar-x fs-1 mb-3 d-block" aria-hidden="true"></i>
                                                <p>Nenhum agendamento encontrado para esta data.</p>
                                            </div>

                                            <div id="appointmentsContainer" class="list-group d-none">
                                                <!-- Lista de agendamentos será preenchida via JavaScript -->
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Aba de Lista -->
                    <div class="tab-pane fade" id="list-tab-pane" role="tabpanel" aria-labelledby="list-tab" tabindex="0">
                        <div class="card">
                            <div class="card-body">
                                <div class="table-responsive">
                                    <table class="table table-hover align-middle">
                                        <thead>
                                            <tr>
                                                <th>Data/Hora</th>
                                                <th>Cliente</th>
                                                <th>Procedimento</th>
                                                <th>Status</th>
                                                <th class="text-end">Ações</th>
                                            </tr>
                                        </thead>
                                        <tbody id="appointmentsTableBody">
                                            <!-- Dados serão preenchidos via JavaScript -->
                                        </tbody>
                                    </table>
                                </div>
                                
                                <nav aria-label="Navegação de páginas" class="mt-4">
                                    <ul class="pagination justify-content-center">
                                        <li class="page-item disabled">
                                            <a class="page-link" href="#" tabindex="-1" aria-disabled="true">Anterior</a>
                                        </li>
                                        <li class="page-item active"><a class="page-link" href="#">1</a></li>
                                        <li class="page-item"><a class="page-link" href="#">2</a></li>
                                        <li class="page-item"><a class="page-link" href="#">3</a></li>
                                        <li class="page-item">
                                            <a class="page-link" href="#">Próximo</a>
                                        </li>
                                    </ul>
                                </nav>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Novo Agendamento -->
    <div class="modal fade" id="agendamentoModal" tabindex="-1" aria-hidden="true" data-bs-backdrop="static">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Novo Agendamento</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
                </div>
                <form id="agendamentoForm">
                    <input type="hidden" id="agendamentoId" name="agendamentoId">
                    <div class="modal-body">
                        <div class="row g-3">
                            <div class="col-md-6">
                                <label for="clienteId" class="form-label">Cliente <span class="text-danger">*</span></label>
                                <select class="form-select" id="clienteId" name="clienteId" required>
                                    <option value="">Selecione um cliente</option>
                                    <!-- Opções serão preenchidas via JavaScript -->
                                </select>
                            </div>
                            <div class="col-md-6">
                                <label for="procedimentoId" class="form-label">Procedimento <span class="text-danger">*</span></label>
                                <select class="form-select" id="procedimentoId" name="procedimentoId" required>
                                    <option value="">Selecione um procedimento</option>
                                    <!-- Opções serão preenchidas via JavaScript -->
                                </select>
                            </div>
                            <div class="col-md-12">
                                <label for="profissionalId" class="form-label">Profissional</label>
                                <select class="form-select" id="profissionalId" name="profissionalId">
                                    <option value="">Selecione um profissional</option>
                                    <!-- Opções serão preenchidas via JavaScript -->
                                </select>
                            </div>
                            <div class="col-md-4">
                                <label for="data" class="form-label">Data <span class="text-danger">*</span></label>
                                <input type="date" class="form-control" id="data" name="data" required>
                            </div>
                            <div class="col-md-4">
                                <label for="horaInicio" class="form-label">Hora Início <span class="text-danger">*</span></label>
                                <input type="time" class="form-control" id="horaInicio" name="horaInicio" required>
                            </div>
                            <div class="col-md-4">
                                <label for="duracao" class="form-label">Duração (min) <span class="text-danger">*</span></label>
                                <input type="number" class="form-control" id="duracao" name="duracao" min="15" step="15" value="60" required>
                            </div>
                            <div class="col-md-6">
                                <label for="valorCobrado" class="form-label">Valor Cobrado (R$) <span class="text-danger">*</span></label>
                                <div class="input-group">
                                    <span class="input-group-text">R$</span>
                                    <input type="number" class="form-control" id="valorCobrado" name="valorCobrado" min="0" step="0.01" required>
                                </div>
                            </div>
                            <div class="col-12">
                                <label for="observacoes" class="form-label">Observações</label>
                                <textarea class="form-control" id="observacoes" name="observacoes" rows="3"></textarea>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                        <button type="submit" class="btn btn-primary" id="btnSalvar">
                            <span class="spinner-border spinner-border-sm d-none" id="loadingSpinner" role="status" aria-hidden="true"></span>
                            <span id="btnText">Salvar</span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Modal de Confirmação de Cancelamento -->
    <div class="modal fade" id="confirmarCancelamentoModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header bg-warning text-dark">
                    <h5 class="modal-title"><i class="bi bi-exclamation-triangle-fill me-2"></i>Cancelar Agendamento</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
                </div>
                <div class="modal-body">
                    <p>Tem certeza que deseja cancelar este agendamento? Esta ação não pode ser desfeita.</p>
                    <input type="hidden" id="confirmarCancelamentoId">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Não, manter agendamento</button>
                    <button type="button" class="btn btn-danger" id="btnConfirmarCancelamento">
                        <i class="bi bi-x-circle me-1"></i> Sim, cancelar
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast de Notificação -->
    <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
        <div id="toastSucesso" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="toast-header bg-success text-white">
                <strong class="me-auto">Sucesso</strong>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Fechar"></button>
            </div>
            <div class="toast-body" id="toastMensagem">
                Operação realizada com sucesso!
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="js/sidebar.js"></script>
    
    <script>
        // Variáveis globais
        let currentDate = new Date();
        
        // Inicialização quando o DOM estiver pronto
        // Inicialização principal ocorre mais abaixo (após checagem de auth)
        
        // Funções principais
        function setupEventListeners() {
            // Navegação do calendário
            document.getElementById('prevMonth')?.addEventListener('click', () => {
                currentDate.setMonth(currentDate.getMonth() - 1);
                renderCalendar();
            });
            
            document.getElementById('nextMonth')?.addEventListener('click', () => {
                currentDate.setMonth(currentDate.getMonth() + 1);
                renderCalendar();
            });
            
            document.getElementById('currentMonth')?.addEventListener('click', () => {
                // Ao clicar no currentMonth, alternar o picker de mês/ano
                const picker = document.getElementById('monthPicker');
                const monthSelect = document.getElementById('monthSelect');
                const yearInput = document.getElementById('yearInput');
                if (!picker || !monthSelect || !yearInput) return;

                // preencher com mês/ano atuais
                monthSelect.value = String(currentDate.getMonth());
                yearInput.value = currentDate.getFullYear();

                // alternar visibilidade
                if (picker.classList.contains('d-none')) {
                    picker.classList.remove('d-none');
                    picker.focus();
                } else {
                    picker.classList.add('d-none');
                }
            });

            // Handlers do monthPicker
            document.getElementById('monthPickerCancel')?.addEventListener('click', (e) => {
                e.preventDefault();
                document.getElementById('monthPicker')?.classList.add('d-none');
            });

            document.getElementById('monthPickerGo')?.addEventListener('click', (e) => {
                e.preventDefault();
                const month = parseInt(document.getElementById('monthSelect').value, 10);
                const year = parseInt(document.getElementById('yearInput').value, 10);
                if (!isNaN(month) && !isNaN(year)) {
                    currentDate.setFullYear(year, month, 1);
                    document.getElementById('monthPicker')?.classList.add('d-none');
                    renderCalendar();
                }
            });

            // Fechar picker ao clicar fora
            document.addEventListener('click', (ev) => {
                const picker = document.getElementById('monthPicker');
                const btn = document.getElementById('currentMonth');
                if (!picker || !btn) return;
                const target = ev.target;
                if (picker.classList.contains('d-none')) return;
                if (btn.contains(target) || picker.contains(target)) return; // clique dentro
                picker.classList.add('d-none');
            });
            
            // Botão de novo agendamento
            document.getElementById('newAgendamentoBtn')?.addEventListener('click', () => {
                const modal = bootstrap.Modal.getOrCreateInstance(document.getElementById('agendamentoModal'));
                const form = document.getElementById('agendamentoForm');
                form.reset();
                
                // Definir data e hora atuais
                const now = new Date();
                const formattedDate = now.toISOString().split('T')[0];
                const formattedTime = now.getHours().toString().padStart(2, '0') + ':' + 
                                   now.getMinutes().toString().padStart(2, '0');
                
                // Preencher os campos de data e hora
                document.getElementById('data').value = formattedDate;
                document.getElementById('horaInicio').value = formattedTime;
                
                // Limpar o ID do agendamento (para garantir que é um novo)
                document.getElementById('agendamentoId').value = '';
                
                // Disparar evento de mudança para preencher outros campos se necessário
                document.getElementById('data').dispatchEvent(new Event('change'));
                document.getElementById('horaInicio').dispatchEvent(new Event('change'));
                
                modal.show();
            });
            
            // Envio do formulário: o listener é registrado na inicialização principal (após checkAuth)
            
            // Botão de confirmação de cancelamento
            document.getElementById('btnConfirmarCancelamento')?.addEventListener('click', confirmarCancelamento);
        }
        
        // loadInitialData definido mais abaixo com lógica completa (carrega via API e autenticação)
        
        // Funções auxiliares
        function formatDate(date) {
            return new Intl.DateTimeFormat('pt-BR').format(date);
        }
        
        function formatTime(date) {
            return date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        }
        
        function showToast(message, isError = false) {
            const toastElement = document.getElementById('toastSucesso');
            const toastBody = document.getElementById('toastMensagem');
            
            if (toastElement && toastBody) {
                const toast = new bootstrap.Toast(toastElement);
                toastBody.textContent = message;
                
                if (isError) {
                    toastElement.querySelector('.toast-header').classList.remove('bg-success');
                    toastElement.querySelector('.toast-header').classList.add('bg-danger');
                } else {
                    toastElement.querySelector('.toast-header').classList.remove('bg-danger');
                    toastElement.querySelector('.toast-header').classList.add('bg-success');
                }
                
                toast.show();
            }
        }
        
        // Funções de manipulação do calendário
        function renderCalendar() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            
            // Atualizar o cabeçalho do mês/ano
            const monthNames = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho",
                              "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];
            document.getElementById('currentMonthText').textContent = `${monthNames[month]} ${year}`;
            
            // Obter o primeiro dia do mês e o último dia do mês
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            
            // Obter o dia da semana do primeiro dia (0 = Domingo, 1 = Segunda, etc.)
            const firstDayIndex = firstDay.getDay();
            
            // Criar array de dias do mês
            let days = [];
            
            // Adicionar dias vazios no início, se necessário
            for (let i = 0; i < firstDayIndex; i++) {
                days.push({ day: '', isCurrentMonth: false });
            }
            
            // Adicionar os dias do mês
            for (let i = 1; i <= lastDay.getDate(); i++) {
                days.push({
                    day: i,
                    isCurrentMonth: true,
                    date: new Date(year, month, i)
                });
            }
            
            // Preencher o calendário
            const calendarDays = document.getElementById('calendarDays');
            if (calendarDays) {
                calendarDays.innerHTML = '';
                
                days.forEach((day, index) => {
                    const dayElement = document.createElement('div');
                    dayElement.className = 'calendar-day';
                    
                    if (day.isCurrentMonth) {
                        dayElement.textContent = day.day;
                        dayElement.addEventListener('click', () => selectDate(day.date));
                        
                        // Destacar o dia atual
                        const today = new Date();
                        if (day.date.toDateString() === today.toDateString()) {
                            dayElement.classList.add('today');
                        }
                    } else {
                        dayElement.classList.add('text-muted');
                    }
                    
                    calendarDays.appendChild(dayElement);
                });
            }
        }
        
        function selectDate(date) {
            // Implementar lógica de seleção de data
            console.log('Data selecionada:', date);
            updateSelectedDate(date);
            loadAppointmentsForDate(date);
        }
        
        function updateSelectedDate(date = new Date()) {
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            const formattedDate = date.toLocaleDateString('pt-BR', options);
            const selectedDateElement = document.getElementById('selectedDate');
            
            if (selectedDateElement) {
                selectedDateElement.textContent = formattedDate.charAt(0).toUpperCase() + 
                                               formattedDate.slice(1);
            }
        }
        
        // Funções de manipulação de agendamentos
        
        function updateAppointmentsList(appointments) {
            const loadingEl = document.getElementById('appointmentsLoading');
            const emptyEl = document.getElementById('appointmentsEmpty');
            const container = document.getElementById('appointmentsContainer');

            if (!container || !loadingEl || !emptyEl) return;

            // Garantir que o loading esteja oculto quando chamamos update
            loadingEl.classList.add('d-none');

            if (!appointments || appointments.length === 0) {
                // Mostrar mensagem de vazio
                container.classList.add('d-none');
                emptyEl.classList.remove('d-none');
                container.innerHTML = '';
                return;
            }

            // Há agendamentos: popular container
            emptyEl.classList.add('d-none');
            container.classList.remove('d-none');
            
            let html = '';

            appointments.sort((a, b) => a.dataHora - b.dataHora).forEach(appt => {
                const time = formatTime(appt.dataHora);
                const statusClass = `status-${(appt.status || '').toString().toUpperCase()}`;
                
                html += `
                    <div class="list-group-item list-group-item-action ${statusClass}">
                        <div class="d-flex w-100 justify-content-between align-items-center">
                            <div class="d-flex align-items-center">
                                <div class="me-3 text-center" style="min-width: 60px">
                                    <div class="fw-bold fs-5">${time}</div>
                                    <small class="text-muted">${formatDate(appt.dataHora)}</small>
                                </div>
                                <div>
                                    <h6 class="mb-1">${appt.cliente}</h6>
                                    <p class="mb-1">${appt.procedimento}</p>
                                </div>
                            </div>
                            <div>
                                <span class="status-badge ${statusClass}">
                                    ${getStatusBadgeIcon(appt.status)} ${getStatusText(appt.status)}
                                </span>
                                <div class="btn-group btn-group-sm ms-2">
                                    <button class="btn btn-outline-primary btn-sm" onclick="editAppointment(${appt.id})">
                                        <i class="bi bi-pencil"></i>
                                    </button>
                                    <button class="btn btn-outline-danger btn-sm" onclick="cancelAppointment(${appt.id})">
                                        <i class="bi bi-x-lg"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function updateAppointmentsTable(appointments) {
            const tbody = document.getElementById('appointmentsTableBody');
            
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            appointments.forEach(appt => {
                const row = document.createElement('tr');
                const statusClass = `status-${appt.status}`;
                
                row.innerHTML = `
                    <td>${formatDate(appt.dataHora)} ${formatTime(appt.dataHora)}</td>
                    <td>${appt.cliente}</td>
                    <td>${appt.procedimento}</td>
                    <td><span class="status-badge ${statusClass}">${getStatusText(appt.status)}</span></td>
                    <td class="text-end">
                        <button class="btn btn-sm btn-outline-primary me-1" onclick="editAppointment(${appt.id})">
                            <i class="bi bi-pencil"></i>
                        </button>
                        <button class="btn btn-sm btn-outline-danger" onclick="cancelAppointment(${appt.id})">
                            <i class="bi bi-x-lg"></i>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        // As funções reais para carregar clientes/procedimentos via API estão definidas mais abaixo
        
        // Funções auxiliares de interface
        function getStatusBadgeIcon(status) {
            const icons = {
                'pendente': 'bi-hourglass-split',
                'confirmado': 'bi-check-circle',
                'cancelado': 'bi-x-circle',
                'finalizado': 'bi-check2-all'
            };
            
            return `<i class="bi ${icons[status] || 'bi-question-circle'}"></i>`;
        }
        
        function getStatusText(status) {
            const statusMap = {
                'pendente': 'Pendente',
                'confirmado': 'Confirmado',
                'cancelado': 'Cancelado',
                'finalizado': 'Finalizado'
            };
            
            return statusMap[status] || status;
        }
        
        // Funções globais para acesso via HTML
        window.editAppointment = async function(id) {
            try {
                console.log('Buscando detalhes do agendamento:', id);
                
                // Buscar os dados reais do agendamento
                const response = await fetchWithAuth(`/api/agendamentos/${id}`);
                if (!response || !response.ok) {
                    throw new Error('Erro ao buscar agendamento');
                }

                const payload = await response.json();
                // API pode retornar { success: true, data: {...} } ou diretamente o objeto
                const agendamento = (payload && payload.success && payload.data) ? payload.data : payload;
                console.log('Dados do agendamento (normalized):', agendamento);

                // Converter as datas para o formato correto (validação antes de usar toISOString)
                const safeParseDate = (v) => {
                    if (!v) return null;
                    try {
                        const d = new Date(v);
                        if (isNaN(d.getTime())) return null;
                        return d;
                    } catch (e) {
                        return null;
                    }
                };

                const startDate = safeParseDate(agendamento.startTime || agendamento.start_time || agendamento.data && (agendamento.data + 'T' + (agendamento.horaInicio || '00:00')));
                const endDate = safeParseDate(agendamento.endTime || agendamento.end_time);
                
        // Calcular a duração em minutos (se possível)
        let durationMinutes = 30;
        if (startDate && endDate) {
            const durationMs = endDate - startDate;
            durationMinutes = Math.floor(durationMs / (1000 * 60));
        }
                
                // Preencher o formulário
                const modal = bootstrap.Modal.getOrCreateInstance(document.getElementById('agendamentoModal'));
                const form = document.getElementById('agendamentoForm');
                
                form.reset();
                
                // Preencher os campos com os dados do agendamento
                document.getElementById('agendamentoId').value = agendamento.id;
                if (agendamento.clienteId) document.getElementById('clienteId').value = agendamento.clienteId;
                if (agendamento.procedimentoId) document.getElementById('procedimentoId').value = agendamento.procedimentoId;
                if (agendamento.profissionalId) document.getElementById('profissionalId').value = agendamento.profissionalId;
                
        // Formatar data e hora (usar valores originais se parsing falhar)
        if (startDate) {
            const dataFormatada = startDate.toISOString().split('T')[0];
            const horaFormatada = startDate.getHours().toString().padStart(2, '0') + ':' + 
                                startDate.getMinutes().toString().padStart(2, '0');
            document.getElementById('data').value = dataFormatada;
            document.getElementById('horaInicio').value = horaFormatada;
        } else {
            // Tentar preencher com campos enviados pelo backend (data/horaInicio)
            if (agendamento.data) document.getElementById('data').value = agendamento.data;
            if (agendamento.horaInicio) document.getElementById('horaInicio').value = agendamento.horaInicio;
        }
                document.getElementById('duracao').value = durationMinutes;
                
    if (agendamento.valorCobrado) document.getElementById('valorCobrado').value = agendamento.valorCobrado;
    if (agendamento.observacoes) document.getElementById('observacoes').value = agendamento.observacoes;
                
        // Disparar eventos de mudança para atualizar campos dependentes
        try {
            document.getElementById('data').dispatchEvent(new Event('change'));
            document.getElementById('horaInicio').dispatchEvent(new Event('change'));
        } catch(e) {
            console.warn('Erro ao disparar eventos de change no modal:', e);
        }
                
                modal.show();
                
            } catch (error) {
                console.error('Erro ao carregar agendamento:', error);
                showToast('Erro ao carregar agendamento: ' + (error.message || 'Tente novamente'), true);
            }
        };
        
        window.cancelAppointment = function(id) {
            // Armazenar o ID no modal
            const confirmId = document.getElementById('confirmarCancelamentoId');
            if (confirmId) {
                confirmId.value = id;
                
                // Mostrar o modal de confirmação
                const modal = new bootstrap.Modal(document.getElementById('confirmarCancelamentoModal'));
                modal.show();
            }
        };
        
        async function confirmarCancelamento() {
            const id = document.getElementById('confirmarCancelamentoId')?.value;
            
            if (!id) {
                showToast('ID do agendamento não informado', true);
                return;
            }
            
            try {
                // Implementar lógica para cancelar o agendamento na API
                console.log('Cancelando agendamento:', id);
                
                // Fechar o modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('confirmarCancelamentoModal'));
                if (modal) modal.hide();
                
                // Recarregar os agendamentos
                loadAppointmentsForDate(currentDate);
                
                showToast('Agendamento cancelado com sucesso');
                
            } catch (error) {
                console.error('Erro ao cancelar agendamento:', error);
                showToast('Erro ao cancelar agendamento', true);
            }
        }
        
        // Função para carregar dados iniciais
        async function loadInitialData() {
            try {
                await Promise.all([
                    loadClientes(),
                    loadProcedimentos(),
                    loadProfissionais()
                ]);
                
                // Carregar agendamentos para a data atual
                const hoje = new Date();
                loadAppointmentsForDate(hoje);
            } catch (error) {
                console.error('Erro ao carregar dados iniciais:', error);
                showToast('Erro ao carregar dados iniciais. Por favor, recarregue a página.', true);
            }
        }

        // Função para fazer requisições autenticadas
        async function fetchWithAuth(url, options = {}) {
            const token = localStorage.getItem('token');
            if (!token) {
                console.error('Token não encontrado no localStorage');
                window.location.href = '/login';
                return null;
            }

            try {
                console.log(`Fazendo requisição para: ${url}`, { method: options.method || 'GET' });
                
                const defaultHeaders = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                };

                const response = await fetch(url, {
                    ...options,
                    headers: {
                        ...defaultHeaders,
                        ...(options.headers || {})
                    },
                    credentials: 'include' // Importante para cookies de sessão
                });

                console.log(`Resposta de ${url}:`, response.status, response.statusText);

                if (response.status === 401) {
                    console.warn('Token inválido ou expirado, redirecionando para login');
                    localStorage.removeItem('token');
                    window.location.href = '/login';
                    return null;
                }

                if (response.status === 403) {
                    console.error('Acesso negado ao recurso:', url);
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || 'Você não tem permissão para acessar este recurso');
                }

                if (response.status >= 500) {
                    console.error('Erro no servidor ao acessar:', url);
                    throw new Error('Ocorreu um erro no servidor. Por favor, tente novamente mais tarde.');
                }

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Erro na requisição:', response.status, errorData);
                    throw new Error(errorData.message || `Erro na requisição: ${response.statusText}`);
                }

                return response;
            } catch (error) {
                console.error(`Erro na requisição para ${url}:`, error);
                throw error;
            }
        }

        // Função para carregar clientes
        async function loadClientes() {
            try {
                const response = await fetchWithAuth('/api/clientes');
                if (!response) return [];
                const clientes = await response.json();
                
                const select = document.getElementById('clienteId');
                if (!select) return;
                
                // Salvar o valor atual
                const valorAtual = select.value;
                
                // Limpar opções existentes (exceto a primeira)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Adicionar clientes ao select
                clientes.forEach(cliente => {
                    if (cliente && cliente.id) {
                        const option = new Option(
                            cliente.nome || `Cliente ${cliente.id}`,
                            cliente.id
                        );
                        select.add(option);
                    }
                });
                
                // Restaurar o valor anterior, se ainda existir
                if (valorAtual) {
                    select.value = valorAtual;
                }
                
                return clientes;
            } catch (error) {
                console.error('Erro ao carregar clientes:', error);
                showToast('Erro ao carregar clientes', true);
                return [];
            }
        }

        // Função para carregar procedimentos
        async function loadProcedimentos() {
            try {
                console.log('Carregando procedimentos...');
                const response = await fetchWithAuth('/api/procedimentos');
                
                // Verificar se a resposta é válida
                if (!response) {
                    console.error('Resposta vazia da API de procedimentos');
                    return [];
                }
                
                let data = response;
                
                // Se for um objeto Response, extrair o JSON
                if (response instanceof Response) {
                    console.log('Convertendo resposta para JSON...');
                    data = await response.json();
                }
                
                // Verificar se os dados são um array
                if (!Array.isArray(data)) {
                    console.error('Resposta inesperada da API de procedimentos:', data);
                    return [];
                }
                
                console.log(`${data.length} procedimentos recebidos`);
                
                // Obter o elemento select
                const select = document.getElementById('procedimentoId');
                if (!select) {
                    console.error('Elemento select#procedimentoId não encontrado');
                    return [];
                }
                
                // Limpar opções existentes (exceto a primeira)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Adicionar procedimentos ao select
                data.forEach(proc => {
                    if (proc && (proc.id || proc._id)) {
                        const id = proc.id || proc._id;
                        // Usando o campo 'name' que vem da API, com fallback para 'descricao' e depois para um valor padrão
                        let nome = proc.name || proc.descricao || `Procedimento ${id}`;
                        
                        // Remover prefixos mantendo a formatação original
                        if (nome.toLowerCase().startsWith('de ')) {
                            nome = nome.substring(3);
                        } else if (nome.toLowerCase().startsWith('descrição do procedimento')) {
                            nome = nome.substring('descrição do procedimento'.length);
                        }
                        
                        // Remover espaços extras e garantir que a primeira letra seja maiúscula
                        nome = nome.trim();
                        const duracao = proc.durationMins || proc.duracaoMinutos || proc.duracao || 60;
                        const valor = proc.defaultPrice || proc.valor || proc.preco || 0;
                        
                        const option = new Option(nome, id);
                        option.dataset.duracao = duracao;
                        option.dataset.valor = valor;
                        select.add(option);
                        
                        console.log(`Adicionado: ${nome} (ID: ${id}, Duração: ${duracao} min, Valor: R$ ${valor})`);
                    }
                });
                
                // Configurar evento de mudança
                const updateFields = function() {
                    const selectedOption = select.options[select.selectedIndex];
                    if (selectedOption && selectedOption.dataset.duracao) {
                        const duracaoInput = document.getElementById('duracao');
                        if (duracaoInput) duracaoInput.value = selectedOption.dataset.duracao;
                    }
                    if (selectedOption && selectedOption.dataset.valor) {
                        const valorInput = document.getElementById('valorCobrado');
                        if (valorInput) valorInput.value = selectedOption.dataset.valor;
                    }
                };
                
                // Adicionar evento de mudança
                select.removeEventListener('change', updateFields);
                select.addEventListener('change', updateFields);
                
                // Disparar evento de mudança para preencher os campos iniciais
                if (select.options.length > 1) {
                    select.dispatchEvent(new Event('change'));
                }
                
                return response;
                
            } catch (error) {
                console.error('Erro ao carregar procedimentos:', error);
                showToast('Erro ao carregar a lista de procedimentos', true);
                return [];
            }
        }

        // Função para carregar profissionais
        async function loadProfissionais() {
            try {
                console.log('Carregando lista de profissionais...');
                const response = await fetchWithAuth('/api/profissionais/my-professionals');
                
                // Se não houver resposta (usuário redirecionado para login)
                if (!response) {
                    console.log('Usuário não autenticado, redirecionando...');
                    return [];
                }
                
                const result = await response.json();
                // A API retorna { data: [...], pagination: {...} }
                const profissionais = Array.isArray(result) ? result : (Array.isArray(result.data) ? result.data : []);
                console.log('Profissionais carregados:', profissionais.length);
                
                const select = document.getElementById('profissionalId');
                if (!select) {
                    console.warn('Elemento select de profissionais não encontrado');
                    return [];
                }
                
                // Limpar opções existentes (exceto a primeira)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Adicionar profissionais ao select
                profissionais.forEach(prof => {
                    if (prof && (prof.id || prof._id)) {
                        const id = prof.id || prof._id;
                        const nome = prof.nome || prof.name || `Profissional ${id}`;
                        
                        const option = new Option(nome, id);
                        // Adicionar dados adicionais como data attributes, se necessário
                        if (prof.especialidade) {
                            option.dataset.especialidade = prof.especialidade;
                        }
                        select.add(option);
                    }
                });
                
                // Disparar evento de mudança para preencher os campos iniciais
                if (select.options.length > 1) {
                    select.dispatchEvent(new Event('change'));
                }
                
                return profissionais;
                
            } catch (error) {
                console.error('Erro ao carregar profissionais:', error);
                showToast('Erro ao carregar a lista de profissionais', true);
                return [];
            }
        }

        // Função para formatar data e hora para o formato ISO 8601
        function formatDateTime(dateStr, timeStr) {
            try {
                if (!dateStr || !timeStr) {
                    console.error('Data ou hora não fornecida:', { dateStr, timeStr });
                    return null;
                }
                
                // Extrair dia, mês e ano da data
                let day, month, year;
                
                if (dateStr.includes('/')) {
                    // Formato DD/MM/YYYY
                    [day, month, year] = dateStr.split('/');
                } else if (dateStr.includes('-')) {
                    // Formato YYYY-MM-DD
                    [year, month, day] = dateStr.split('-');
                } else {
                    console.error('Formato de data não suportado:', dateStr);
                    return null;
                }
                
                // Garantir que o tempo tenha minutos
                let hours, minutes;
                if (timeStr.includes(':')) {
                    [hours, minutes] = timeStr.split(':');
                } else {
                    hours = timeStr;
                    minutes = '00';
                }
                
                // Criar string no formato YYYY-MM-DDTHH:MM:SS
                const pad = num => num.toString().padStart(2, '0');
                const date = new Date(
                    parseInt(year, 10),
                    parseInt(month, 10) - 1,
                    parseInt(day, 10),
                    parseInt(hours, 10),
                    parseInt(minutes, 10),
                    0
                );
                
                if (isNaN(date.getTime())) {
                    console.error('Data/hora inválida:', { dateStr, timeStr });
                    return null;
                }
                
                // Formatar para ISO 8601 sem timezone (o servidor vai tratar o timezone)
                return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}` +
                       `T${pad(date.getHours())}:${pad(date.getMinutes())}:00`;
            } catch (error) {
                console.error('Erro ao formatar data/hora:', error);
                return null;
            }
        }

        // Função para calcular o horário de término
        function calculateEndTime(startTime, duration) {
            try {
                if (!startTime) {
                    console.error('Hora de início não fornecida');
                    return null;
                }
                
                const durationMinutes = parseInt(duration, 10);
                if (isNaN(durationMinutes)) {
                    console.error('Duração inválida:', duration);
                    return null;
                }
                
                // Converter a string de data/hora para objeto Date
                let startDate;
                if (typeof startTime === 'string') {
                    // Se for uma string ISO, converter diretamente
                    if (startTime.includes('T')) {
                        startDate = new Date(startTime);
                    } else {
                        // Se for apenas hora, assumir data atual
                        const [hours, minutes] = startTime.split(':');
                        const now = new Date();
                        startDate = new Date(
                            now.getFullYear(),
                            now.getMonth(),
                            now.getDate(),
                            parseInt(hours, 10),
                            parseInt(minutes || '0', 10),
                            0
                        );
                    }
                } else if (startTime instanceof Date) {
                    startDate = new Date(startTime);
                } else {
                    console.error('Formato de data de início inválido:', startTime);
                    return null;
                }
                
                if (isNaN(startDate.getTime())) {
                    console.error('Hora de início inválida:', startTime);
                    return null;
                }
                
                // Adicionar a duração
                const endDate = new Date(startDate.getTime() + (durationMinutes * 60 * 1000));
                
                // Retornar no mesmo formato que formatDateTime
                const pad = num => num.toString().padStart(2, '0');
                return `${endDate.getFullYear()}-${pad(endDate.getMonth() + 1)}-${pad(endDate.getDate())}` +
                       `T${pad(endDate.getHours())}:${pad(endDate.getMinutes())}:00`;
            } catch (error) {
                console.error('Erro ao calcular horário de término:', error);
                return null;
            }
        }

        // Função para salvar ou atualizar um agendamento
        // Função para salvar ou atualizar um agendamento
async function submitAgendamentoForm(form, isEdit = false) {
    const btnSalvar = document.getElementById('btnSalvar');
    const spinner = document.getElementById('loadingSpinner');
    const btnText = document.getElementById('btnText');
    
    try {
        // Mostrar loading
        btnSalvar.disabled = true;
        spinner.classList.remove('d-none');
        btnText.textContent = 'Salvando...';
        
        const formData = new FormData(form);
        
        // Obter valores do formulário (fallback para valor diretamente do DOM se o FormData estiver vazio)
        let agendamentoId = formData.get('agendamentoId');
        if (!agendamentoId) {
            const idEl = document.getElementById('agendamentoId');
            if (idEl) agendamentoId = idEl.value || '';
        }
        const clienteId = parseInt(formData.get('clienteId'));
        const procedimentoId = parseInt(formData.get('procedimentoId'));
        const profissionalIdStr = formData.get('profissionalId');
        const profissionalId = profissionalIdStr && profissionalIdStr !== 'null' && profissionalIdStr !== 'undefined' ? parseInt(profissionalIdStr) : null;
        const valorCobrado = parseFloat(formData.get('valorCobrado') || '0');
        const dataInicio = formData.get('data');
        const horaInicio = formData.get('horaInicio');
        const duracao = parseInt(formData.get('duracao') || '30');
        const observacoes = formData.get('observacoes');

        // Registrar qual opção de procedimento está selecionada (id e texto)
        try {
            const procSelect = document.getElementById('procedimentoId');
            if (procSelect) {
                const selectedOpt = procSelect.options[procSelect.selectedIndex];
                console.log('Procedimento selecionado no select:', { value: selectedOpt ? selectedOpt.value : null, text: selectedOpt ? selectedOpt.text : null, dataset: selectedOpt ? selectedOpt.dataset : null });
            } else {
                console.warn('Elemento select#procedimentoId não encontrado no DOM ao submeter o formulário');
            }
        } catch (e) {
            console.warn('Erro ao registrar procedimento selecionado:', e);
        }
        
        // Validar campos obrigatórios
        if (!clienteId || !procedimentoId || !dataInicio || !horaInicio || !duracao) {
            throw new Error('Preencha todos os campos obrigatórios');
        }
        
        // Formatar data e hora
        const startTime = new Date(`${dataInicio}T${horaInicio}`);
        const endTime = new Date(startTime.getTime() + (duracao * 60000));
        
    // Formatar para ISO string
    const startTimeISO = startTime.toISOString();
    const endTimeISO = endTime.toISOString();
        
        console.log('Dados do agendamento:', {
            clienteId,
            procedimentoId,
            profissionalId,
            valorCobrado,
            startTime: startTimeISO,
            endTime: endTimeISO,
            observacoes
        });

        // Verificar disponibilidade
        console.log('Verificando disponibilidade...');
        const disponivel = await verificarDisponibilidade(
            profissionalId,
            startTimeISO,
            endTimeISO,
            agendamentoId ? parseInt(agendamentoId) : null
        );
        
        if (!disponivel) {
            throw new Error('Já existe um agendamento neste horário');
        }
        
        // Preparar dados para envio
        // Obter o nome do procedimento selecionado para maior clareza no backend
        let procedimentoNome = null;
        try {
            const procSelect = document.getElementById('procedimentoId');
            const selectedOpt = procSelect ? procSelect.options[procSelect.selectedIndex] : null;
            if (selectedOpt) procedimentoNome = selectedOpt.text;
        } catch (e) {
            console.warn('Não foi possível obter o nome do procedimento selecionado:', e);
        }

        const data = {
            clienteId,
            procedimentoId,
            profissionalId,
            valorCobrado,
            // incluir data e hora originais para que o backend possa retornar o wall-clock
            data: dataInicio,
            horaInicio: horaInicio,
            startTime: startTimeISO,
            endTime: endTimeISO,
            observacoes: observacoes || null,
            status: 'AGENDADO',
            procedimentoNome
        };

        console.log('Enviando dados para a API:', data);
        
        // Determinar a URL e o método HTTP
        const url = isEdit && agendamentoId 
            ? `/api/agendamentos/${agendamentoId}`
            : '/api/agendamentos';
            
    // Usar PATCH para edição parcial (mais seguro) e POST para criação
    const method = isEdit ? 'PATCH' : 'POST';
        
        // Fazer a requisição para a API
        const response = await fetch(url, {
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
            },
            body: JSON.stringify(data)
        });
        
        // Tentar ler JSON; se o servidor retornar HTML (404/500), lançar erro informativo
        let responseData = null;
        const text = await response.text();
        try {
            responseData = text ? JSON.parse(text) : null;
        } catch (e) {
            console.error('Resposta não-JSON da API ao criar/atualizar agendamento:', text);
            throw new Error(`Resposta inválida do servidor: ${response.status} ${response.statusText}`);
        }

        if (!response.ok) {
            console.error('Resposta de erro da API ao criar/agendar:', response.status, responseData);
            // Mostrar toast com a mensagem retornada pelo servidor, se houver
            showToast(responseData.error || responseData.message || 'Erro ao salvar agendamento. Verifique os logs do servidor.', true);
            throw new Error(responseData.error || responseData.message || 'Erro ao salvar agendamento');
        }

        console.log('Resposta da API:', responseData);
        
        // Recarregar os agendamentos
        await loadAppointmentsForDate(currentDate);
        
        // Fechar o modal de forma robusta
        (function closeAgendamentoModal() {
            try {
                const modalEl = document.getElementById('agendamentoModal');
                if (!modalEl) return;

                // Garante que existe uma instância do modal (cria se necessário)
                const modalInstance = bootstrap.Modal.getOrCreateInstance(modalEl);
                modalInstance.hide();

                // Remover manualmente qualquer backdrop residual
                const backdrop = document.querySelector('.modal-backdrop');
                if (backdrop && backdrop.parentNode) {
                    backdrop.parentNode.removeChild(backdrop);
                }

                // Garantir que a classe modal-open foi removida do body
                document.body.classList.remove('modal-open');

                // Resetar o formulário para estado limpo
                try {
                    form.reset();
                    document.getElementById('agendamentoId').value = '';
                } catch (e) {
                    console.warn('Falha ao resetar o formulário do agendamento:', e);
                }
            } catch (e) {
                console.error('Erro ao tentar fechar o modal de agendamento:', e);
            }
        })();
        
        // Mostrar mensagem de sucesso
        showToast(`Agendamento ${isEdit ? 'atualizado' : 'criado'} com sucesso!`, false);
        
    } catch (error) {
        console.error('Erro ao salvar agendamento:', error);
        showToast(error.message || 'Erro ao salvar agendamento. Verifique os dados e tente novamente.', true);
    } finally {
        // Restaurar o botão
        btnSalvar.disabled = false;
        spinner.classList.add('d-none');
        btnText.textContent = 'Salvar';
    }
}
        // Função para mostrar mensagem de sucesso
        function showSuccess(message) {
            Swal.fire({
                title: 'Sucesso!',
                text: message,
                icon: 'success',
                confirmButtonColor: '#f0b354',
                timer: 2000,
                timerProgressBar: true
            });
        }

        // Função para formatar data para string ISO sem milissegundos
        function formatDateForAPI(dateString) {
            if (!dateString) return null;
            const date = new Date(dateString);
            // Ajusta para o fuso horário local e formata como YYYY-MM-DDTHH:MM:SS
            const pad = num => num.toString().padStart(2, '0');
            const tzOffset = -date.getTimezoneOffset();
            const tzSign = tzOffset >= 0 ? '+' : '-';
            const tzHours = Math.floor(Math.abs(tzOffset) / 60);
            const tzMinutes = Math.abs(tzOffset) % 60;
            
            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T` +
                   `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}` +
                   `${tzSign}${pad(tzHours)}:${pad(tzMinutes)}`;
        }

        // Função temporária para verificação de disponibilidade
        // Retorna true para permitir todos os agendamentos
        async function verificarDisponibilidade(profissionalId, startTime, endTime, agendamentoId = null) {
            console.log('Verificação de disponibilidade temporariamente desativada - Permitindo todos os agendamentos');
            return true;
        }
        
        // Função original comentada
        /*
        async function verificarDisponibilidade(profissionalId, startTime, endTime, agendamentoId = null) {
            try {
                console.log('Verificando disponibilidade para:', {
                    profissionalId,
                    startTime,
                    endTime,
                    agendamentoId: agendamentoId || 'Novo agendamento'
                });

                if (!profissionalId) {
                    console.log('Nenhum profissional selecionado, considerando horário disponível');
                    return true;
                }

                const url = `/api/agendamentos/verificar-disponibilidade?` +
                           `profissionalId=${profissionalId}&` +
                           `dataInicio=${encodeURIComponent(startTime)}&` +
                           `dataFim=${encodeURIComponent(endTime)}`;

                console.log('Enviando parâmetros de disponibilidade:', url);

                const response = await fetchWithAuth(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response) {
                    console.error('Resposta inválida ao verificar disponibilidade');
                    return false;
                }

                const result = await response.json();
                
                if (response.status === 200 && result.success === true) {
                    console.log('Disponibilidade verificada:', result.disponivel);
                    return result.disponivel === true;
                }
                
                console.error('Erro ao verificar disponibilidade:', result?.error || 'Erro desconhecido');
                return false;
                
            } catch (error) {
                console.error('Erro na verificação de disponibilidade:', error);
                return false;
            }
        }
        */
        
        // Função para carregar agendamentos
        async function loadAppointmentsForDate(date) {
            try {
                console.log('Carregando agendamentos para:', date);
                // Exibir spinner
                try {
                    const loadingEl = document.getElementById('appointmentsLoading');
                    const emptyEl = document.getElementById('appointmentsEmpty');
                    const containerEl = document.getElementById('appointmentsContainer');
                    if (loadingEl) loadingEl.classList.remove('d-none');
                    if (emptyEl) emptyEl.classList.add('d-none');
                    if (containerEl) containerEl.classList.add('d-none');
                } catch (e) {
                    console.warn('Não foi possível manipular elementos de loading/empty/container:', e);
                }
                
                // Construir start/end ISO para o dia (usando componentes locais para evitar shifts de timezone)
                const year = date.getFullYear();
                const month = date.getMonth(); // 0-based
                const day = date.getDate();

                const start = new Date(year, month, day, 0, 0, 0, 0);
                const end = new Date(year, month, day, 23, 59, 59, 999);

                const startISO = start.toISOString();
                const endISO = end.toISOString();

                console.log('Buscando agendamentos para intervalo local:', { startISO, endISO, date });
                const response = await fetchWithAuth(`/api/agendamentos?start=${encodeURIComponent(startISO)}&end=${encodeURIComponent(endISO)}`);
                
                if (!response) {
                    return [];
                }
                
                const body = await response.json();

                // Backend retorna { success: true, data: [...] } em várias rotas
                let agendamentos = [];

                if (Array.isArray(body)) {
                    agendamentos = body;
                } else if (body && Array.isArray(body.data)) {
                    agendamentos = body.data;
                } else if (body && Array.isArray(body)) {
                    agendamentos = body;
                } else {
                    console.warn('Resposta de agendamentos inesperada:', body);
                }

                // Mapear cada agendamento para o formato esperado pela UI
                const mapped = agendamentos.map(ag => {
                    // Priorizar campos formatados do backend (data e horaInicio) para preservar o wall-clock
                    let start = null;
                    try {
                        if (ag.data && ag.horaInicio) {
                            // Construir data/hora local por componentes (evita shift ao interpretar ISO UTC)
                            try {
                                const [y, m, d] = ag.data.split('-').map(s => parseInt(s, 10));
                                const [hh, mm] = ag.horaInicio.split(':').map(s => parseInt(s, 10));
                                if (!isNaN(y) && !isNaN(m) && !isNaN(d) && !isNaN(hh) && !isNaN(mm)) {
                                    start = new Date(y, m - 1, d, hh, mm, 0, 0);
                                } else {
                                    // fallback para parsing direto
                                    start = new Date(`${ag.data}T${ag.horaInicio}`);
                                }
                            } catch (e) {
                                console.warn('Erro ao construir data por componentes, fallback para new Date(string):', e);
                                start = new Date(`${ag.data}T${ag.horaInicio}`);
                            }
                        } else if (ag.startTime) {
                            start = new Date(ag.startTime);
                        }
                    } catch (e) {
                        console.warn('Erro ao construir data do agendamento:', e, ag);
                        start = ag.startTime ? new Date(ag.startTime) : null;
                    }
                    // Debug: log valores de entrada e data construída
                    console.debug('Map agendamento:', {
                        id: ag.id,
                        data: ag.data,
                        horaInicio: ag.horaInicio,
                        startTimeRaw: ag.startTime,
                        constructedStart: start ? start.toString() : null,
                        constructedStartISO: start ? start.toISOString() : null,
                        formattedDate: start ? start.toLocaleDateString('pt-BR') : null,
                        formattedTime: start ? start.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }) : null
                    });
                    const duracao = ag.duracao || (ag.procedimento?.duracaoMinutos) || ag.procedimentos?.durationMins || 30;
                    return {
                        id: ag.id,
                        cliente: ag.cliente?.nome || ag.clientes?.nome || ag.clienteNome || (ag.clientes && ag.clientes.nome) || 'Cliente',
                        procedimento: ag.procedimento?.name || ag.procedimentos?.name || ag.procedimentoNome || 'Procedimento',
                        dataHora: start,
                        status: ag.status || 'AGENDADO',
                        duracao: duracao,
                        valorCobrado: ag.valorCobrado || 0,
                        observacoes: ag.observacoes || ag.observacoes || ''
                    };
                }).filter(a => a.dataHora);

                // Atualizar a UI com os resultados
                updateAppointmentsList(mapped);
                updateAppointmentsTable(mapped);

                return mapped;
            } catch (error) {
                console.error('Erro ao carregar agendamentos:', error);
                showToast('Erro ao carregar agendamentos', true);
                // Garantir que o spinner seja escondido e mostrar mensagem vazia
                try {
                    const loadingEl = document.getElementById('appointmentsLoading');
                    const emptyEl = document.getElementById('appointmentsEmpty');
                    const containerEl = document.getElementById('appointmentsContainer');
                    if (loadingEl) loadingEl.classList.add('d-none');
                    if (containerEl) containerEl.classList.add('d-none');
                    if (emptyEl) emptyEl.classList.remove('d-none');
                } catch (e) {
                    console.warn('Erro ao esconder spinner após falha:', e);
                }
                return [];
            }
        }

        // Verificar autenticação ao carregar a página
        function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = '/login';
                return false;
            }
            return true;
        }

        // Inicialização da página
        document.addEventListener('DOMContentLoaded', function() {
            if (!checkAuth()) return;
            
            // Inicializar a barra lateral
            if (window.initSidebar) {
                window.initSidebar();
            }
            
            // Configurar eventos
            setupEventListeners();
            
            // Carregar dados iniciais
            loadInitialData();
            
            // Inicializar o calendário
            renderCalendar();
            
            // Configurar o formulário
            const form = document.getElementById('agendamentoForm');
            if (form) {
                form.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const isEdit = !!document.getElementById('agendamentoId').value;
                    await submitAgendamentoForm(form, isEdit);
                });
            }
        });
    </script>
</body>
</html>
